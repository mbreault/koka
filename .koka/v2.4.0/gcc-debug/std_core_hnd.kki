/* Internal effect handler primitives.

  Internal primitives to implement evidence based algebraic
  effect handlers. These are emitted by the compiler during evidence
  translation and this module is always implicitly imported.

  The paper:

  Ningning Xie, and Daan Leijen. _Generalized Evidence Passing for Effect Handlers_,
  or _efficient compilation of effect handlers to C_. 
  Proceedings of the ACM International Conference on Functional Programming (ICFP'21), 
  August 2021, Vol 5: pp. 71, doi: 10.1145/3473576.
  <https://www.microsoft.com/en-us/research/publication/generalized-evidence-passing-for-effect-handlers-or-efficient-compilation-of-effect-handlers-to-c/>

  describes how the monadic evidence translation works on which this
  module is based. This module is compiled _without monadic translation_ and
  thus we need to do this by hand in this module which allows us to implement
  most primitives directly in Koka keeping the external C/JavaScript/etc primitives
  to a minimum.
*/
module interface std/core/hnd
 
//------------------------------
//#kki: import declarations
 
import std/core/types = std/core/types = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
 
//------------------------------
//#kki: local imported aliases
 
 
//------------------------------
//#kki: type declarations
 
// control flow context:
//                 -1: none: bottom
//                   /          \
// 0: except: never resumes   1: linear: resumes exactly once
//                   \          /
//           2: affine: resumes never or once
//                        |
//     3: multi: resumes never, once, or multiple times
pub alias cfc = std/core/types/int32 = 1;
// Evidence vectors
type evv <(e :: E)> :: E -> V ;
// The tag of a handler identifies the type at runtime (e.g. `"exn/core/std"`).
pub value{0,1} type htag <(a :: (E, V) -> V)> :: ((E, V) -> V) -> V {
  con Htag(tagname: std/core/types/string) : forall<(a :: (E, V) -> V)> (tagname : std/core/types/string) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
};
// Each handler in the context has a unique marker.
value{4,0} type marker <(e :: E),a> :: (E, V) -> V {
  // Each handler in the context has a unique marker.
  con Marker(m: std/core/types/int32) : forall<(e :: E),a> (m : std/core/types/int32) -> (marker :: (E, V) -> V)<(e :: E),a>;
};
// Effect handler evidence of a handler `:h` in the context.
pub type ev <(a :: (E, V) -> V)> :: ((E, V) -> V) -> V {
  con Ev<(e :: E),b>(htag: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, marker: (marker :: (E, V) -> V)<(e :: E),b>, hnd: (a :: (E, V) -> V)<(e :: E),b>, cfc: (cfc == 1 std/core/types/int32), hevv: (evv :: E -> V)<(e :: E)>) : forall<(a :: (E, V) -> V),(e :: E),b> (htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, marker : (marker :: (E, V) -> V)<(e :: E),b>, hnd : (a :: (E, V) -> V)<(e :: E),b>, cfc : (cfc == 1 std/core/types/int32), hevv : (evv :: E -> V)<(e :: E)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
};
pub value{0,1} type clause0 <a,(b :: (E, V) -> V),(e :: E),c> :: (V, (E, V) -> V, E, V) -> V {
  con Clause0(clause: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : forall<a,(b :: (E, V) -> V),(e :: E),c> (clause : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
};
pub value{0,1} type clause1 <a,b,(c :: (E, V) -> V),(e :: E),d> :: (V, V, (E, V) -> V, E, V) -> V {
  con Clause1(clause: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (clause : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
};
pub value{0,1} type clause2 <a,b,c,(d :: (E, V) -> V),(e :: E),a1> :: (V, V, V, (E, V) -> V, E, V) -> V {
  con Clause2(clause: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (clause : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
};
pub alias ev-index = std/core/types/ssize_t = 1;
value{0,1} type resume-result <a,b> :: (V, V) -> V {
  con Deep(result: a) : forall<a,b> (result : a) -> (resume-result :: (V, V) -> V)<a,b>;
  con Shallow(result: a) : forall<a,b> (result : a) -> (resume-result :: (V, V) -> V)<a,b>;
  con Finalize(result: b) : forall<a,b> (result : b) -> (resume-result :: (V, V) -> V)<a,b>;
};
pub value{0,1} type resume-context <a,(e :: E),(e1 :: E),b> :: (V, E, E, V) -> V {
  con Resume-context(k: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : forall<a,(e :: E),(e1 :: E),b> (k : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) -> (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>;
};
pub type yield-info ;
value{0,2} type yld <(e :: E),a,b> :: (E, V, V) -> V {
  con Pure : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con YieldingFinal : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con Yielding : forall<(e :: E),a,b> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
  con Yield<c>(clause: (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, cont: (() -> c) -> (e :: E) a) : forall<(e :: E),a,b,c> (clause : (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, cont : (() -> c) -> (e :: E) a) -> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
};
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Retrieves the `tagname` constructor field of the `:htag` type.
fun tagname : forall<(a :: (E, V) -> V)> (^ htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> std/core/types/string;
pub fun .copy : forall<(a :: (E, V) -> V)> (.this : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, tagname : (std/core/types/optional :: V -> V)<std/core/types/string>) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// Automatically generated. Retrieves the `m` constructor field of the `:marker` type.
fun m : forall<(e :: E),a> (^ marker : (marker :: (E, V) -> V)<(e :: E),a>) -> std/core/types/int32;
fun .copy.1 : forall<(e :: E),a> (.this : (marker :: (E, V) -> V)<(e :: E),a>, m : (std/core/types/optional :: V -> V)<std/core/types/int32>) -> (marker :: (E, V) -> V)<(e :: E),a>;
// Automatically generated. Retrieves the `htag` constructor field of the `:ev` type.
fun htag : forall<(a :: (E, V) -> V)> (^ ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// Automatically generated. Retrieves the `cfc` constructor field of the `:ev` type.
fun cfc : forall<(a :: (E, V) -> V)> (^ ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> cfc;
pub fun .copy.2 : forall<(a :: (E, V) -> V),(e :: E),b> (.this : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, htag : (std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>, marker : (marker :: (E, V) -> V)<(e :: E),b>, hnd : (a :: (E, V) -> V)<(e :: E),b>, cfc : (std/core/types/optional :: V -> V)<cfc>, hevv : (evv :: E -> V)<(e :: E)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause0` type.
fun clause : forall<a,(b :: (E, V) -> V),(e :: E),c> (^ clause0 : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>) -> (((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a);
pub fun .copy.3 : forall<a,(b :: (E, V) -> V),(e :: E),c> (.this : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>, clause : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause1` type.
fun clause.1 : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (^ clause1 : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>) -> (((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b);
pub fun .copy.4 : forall<a,b,(c :: (E, V) -> V),(e :: E),d> (.this : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>, clause : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
// Automatically generated. Retrieves the `clause` constructor field of the `:clause2` type.
fun clause.2 : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (^ clause2 : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>) -> (((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c);
pub fun .copy.5 : forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> (.this : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>, clause : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
// Automatically generated. Tests for the `Deep` constructor of the `:resume-result` type.
fun is-deep : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Shallow` constructor of the `:resume-result` type.
fun is-shallow : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Finalize` constructor of the `:resume-result` type.
fun is-finalize : forall<a,b> (^ resume-result : (resume-result :: (V, V) -> V)<a,b>) -> std/core/types/bool;
// Automatically generated. Retrieves the `k` constructor field of the `:resume-context` type.
fun k : forall<a,(e :: E),(e1 :: E),b> (^ .this : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b);
pub fun .copy.6 : forall<a,(e :: E),(e1 :: E),b> (.this : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, k : (std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>) -> (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>;
// Automatically generated. Tests for the `Pure` constructor of the `:yld` type.
fun is-pure : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `YieldingFinal` constructor of the `:yld` type.
fun is-yieldingFinal : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Yielding` constructor of the `:yld` type.
fun is-yielding : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// Automatically generated. Tests for the `Yield` constructor of the `:yld` type.
fun is-yield : forall<a,b,(e :: E)> (^ yld : (yld :: (E, V, V) -> V)<(e :: E),a,b>) -> std/core/types/bool;
// (dynamically) find evidence insertion/deletion index in the evidence vector
pub fun .evv-index : forall<(e :: E),(a :: (E, V) -> V)> (htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (e :: E) ev-index;
pub fun .evv-is-affine : () -> std/core/types/bool;
pub fun .evv-lookup : forall<(a :: (E, V) -> V)> (htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
// mask for builtin effects without a handler or evidence
pub fun .mask-builtin : forall<a,(e :: E),(e1 :: E)> (action : () -> (e :: E) a) -> (e1 :: E) a;
pub fun .new-htag : forall<(a :: (E, V) -> V)> (tag : std/core/types/string) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
pub fun .open-none0 : forall<a,(e :: E),(e1 :: E)> (f : () -> (e :: E) a) -> (e1 :: E) a;
pub fun .open-none1 : forall<a,b,(e :: E),(e1 :: E)> (f : (a) -> (e :: E) b, x1 : a) -> (e1 :: E) b;
pub fun .open-none2 : forall<a,b,c,(e :: E),(e1 :: E)> (f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub fun .open-none3 : forall<a,b,c,d,(e :: E),(e1 :: E)> (f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub fun .open-none4 : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
//inline extern cast-hnd( h : h<e1,r> ) : e h<e,r> { inline "#1"//inline extern cast-marker( m : marker<e1,r> ) : e marker<e,r> { inline "#1"
pub fun .perform0 : forall<a,(e :: E),(b :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op : forall<(e1 :: E),c> ((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>) -> (e :: E) a;
pub fun .perform1 : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x : a) -> (e :: E) b;
pub fun .perform2 : forall<a,b,c,(e :: E),(d :: (E, V) -> V)> (evx : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op : forall<(e1 :: E),a1> ((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>, x : a, y : b) -> (e :: E) c;
fun evv-get : forall<(e :: E)> () -> (e :: E) (evv :: E -> V)<(e :: E)>;
fun evv-insert : forall<(e :: E),(e1 :: E),(a :: (E, V) -> V)> (evv : (evv :: E -> V)<(e :: E)>, ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(e1 :: E)>;
fun fresh-marker-int : () -> std/core/types/int32;
fun evv-eq : forall<(e :: E)> (evv0 : (evv :: E -> V)<(e :: E)>, evv1 : (evv :: E -> V)<(e :: E)>) -> std/core/types/bool;
fun guard : forall<(e :: E)> (w : (evv :: E -> V)<(e :: E)>) -> (e :: E) ();
pub fun yield-extend : forall<a,b,(e :: E)> (next : (a) -> (e :: E) b) -> (e :: E) b;
fun yield-cont : forall<a,(e :: E),b> (f : forall<c> ((c) -> (e :: E) a, c) -> (e :: E) b) -> (e :: E) b;
fun yield-prompt : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>) -> (yld :: (E, V, V) -> V)<(e :: E),a,b>;
fun yield-to-final : forall<a,(e :: E),(e1 :: E),b> (m : (marker :: (E, V) -> V)<(e1 :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e1 :: E) b) -> (e1 :: E) b) -> (e :: E) a;
fun evv-swap-delete : forall<(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool) -> (e1 :: E) (evv :: E -> V)<(e :: E)>;
fun fresh-marker-named-int : () -> std/core/types/int32;
fun evv-swap-create : forall<(e :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>) -> (e :: E) (evv :: E -> V)<(e :: E)>;
// For interal use
fun xperform1 : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x : a) -> (e :: E) b;
fun yield-to-prim : forall<a,(e :: E),(e1 :: E),b> (m : (marker :: (E, V) -> V)<(e1 :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e1 :: E) b) -> (e1 :: E) b) -> (e :: E) (() -> a);
pub fun clause-tail-noyield0 : forall<(e :: E),a,b,(c :: (E, V) -> V)> (op : () -> (e :: E) b) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(c :: (E, V) -> V),(e :: E),a>;
pub fun clause-tail-noyield1 : forall<(e :: E),a,b,c,(d :: (E, V) -> V)> (op : (b) -> (e :: E) c) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<b,c,(d :: (E, V) -> V),(e :: E),a>;
pub fun clause-tail-noyield2 : forall<(e :: E),a,b,c,d,(a1 :: (E, V) -> V)> (op : (b, c) -> (e :: E) d) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,c,d,(a1 :: (E, V) -> V),(e :: E),a>;
fun evv-swap-with : forall<(a :: (E, V) -> V),(e :: E)> (ev : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (evv :: E -> V)<(e :: E)>;
pub fun clause-value : forall<a,(e :: E),(b :: (E, V) -> V),c> (v : a) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
fun evv-show : forall<(e :: E)> (evv : (evv :: E -> V)<(e :: E)>) -> std/core/types/string;
pub fun unsafe-reyield : forall<a,(e :: E)> (yld : yield-info) -> (e :: E) a;
fun yield-capture : forall<(e :: E)> () -> (e :: E) yield-info;
fun get : forall<a,(h :: H)> (ref : (std/core/types/ref :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/div :: X)> a;
pub fun hidden-htag : forall<(a :: (E, V) -> V)> (tag : std/core/types/string) -> (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>;
pub fun resume : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : a) -> (e :: E) b;
fun resume-final : forall<a> () -> a;
pub fun resume-shallow : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : a) -> (e1 :: E) b;
fun fresh-marker : forall<(e :: E),a> () -> (marker :: (E, V) -> V)<(e :: E),a>;
pub fun yield-bind : forall<a,b,(e :: E)> (x : a, next : (a) -> (e :: E) b) -> (e :: E) b;
fun prompt : forall<a,(e :: E),(b :: (E, V) -> V),c> (w0 : (evv :: E -> V)<(e :: E)>, w1 : (evv :: E -> V)<(e :: E)>, ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, m : (marker :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, result : a) -> (e :: E) c;
pub fun .hhandle : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (tag : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, cfc : cfc, h : (b :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, action : () -> (e1 :: E) a) -> (e :: E) c;
fun mask-at1 : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool, action : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub fun .mask-at : forall<a,(e :: E),(e1 :: E)> (i : ev-index, behind : std/core/types/bool, action : () -> (e :: E) a) -> (e1 :: E) a;
fun fresh-marker-named : forall<(e :: E),a> () -> (marker :: (E, V) -> V)<(e :: E),a>;
pub fun .named-handle : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (tag : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, cfc : cfc, h : (b :: (E, V) -> V)<(e :: E),c>, ret : (a) -> (e :: E) c, action : ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) -> (e :: E) c;
fun open-at1 : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub fun .open-at0 : forall<a,(e :: E),(e1 :: E)> (i : ev-index, f : () -> (e :: E) a) -> (e1 :: E) a;
pub fun .open-at1 : forall<a,b,(e :: E),(e1 :: E)> (i : ev-index, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub fun .open-at2 : forall<a,b,c,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub fun .open-at3 : forall<a,b,c,d,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub fun .open-at4 : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (i : ev-index, f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
fun open1 : forall<a,b,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub fun .open0 : forall<a,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : () -> (e :: E) a) -> (e1 :: E) a;
pub fun .open1 : forall<a,b,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a) -> (e :: E) b, x : a) -> (e1 :: E) b;
pub fun .open2 : forall<a,b,c,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e1 :: E) c;
pub fun .open3 : forall<a,b,c,d,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e1 :: E) d;
pub fun .open4 : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (indices : (std/core/types/vector :: V -> V)<ev-index>, f : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e1 :: E) a1;
pub fun .perform3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, op : forall<(e1 :: E),b1> ((a1 :: (E, V) -> V)<(e1 :: E),b1>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e1 :: E),b1>, x1 : a, x2 : b, x3 : c) -> (e :: E) d;
pub fun .perform4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, op : forall<(e1 :: E),c1> ((b1 :: (E, V) -> V)<(e1 :: E),c1>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e1 :: E),c1>, x1 : a, x2 : b, x3 : c, x4 : d) -> (e :: E) a1;
fun yield-to : forall<a,(e :: E),b> (m : (marker :: (E, V) -> V)<(e :: E),b>, clause : (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) -> (e :: E) b) -> (e :: E) a;
pub fun clause-control-raw0 : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (op : ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),c>) -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
pub fun clause-control-raw1 : forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> (op : (x : a, r : (resume-context :: (V, E, E, V) -> V)<b,(e :: E),(e1 :: E),d>) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
pub fun clause-control-raw2 : forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> (op : (x1 : a, x2 : b, r : (resume-context :: (V, E, E, V) -> V)<c,(e :: E),(e1 :: E),a1>) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub fun clause-control-raw3 : forall<a,b,c,d,(e :: E),(e1 :: E),(a1 :: (E, V) -> V),b1> (op : (x1 : a, x2 : b, x3 : c, r : (resume-context :: (V, E, E, V) -> V)<d,(e :: E),(e1 :: E),b1>) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub fun finalize : forall<a,(e :: E),(e1 :: E),b> (r : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x : b) -> (e :: E) b;
fun protect-check : forall<a,(e :: E),b> (resumed : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/bool>, k : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b, res : b) -> (e :: E) b;
fun protect : forall<a,b,(e :: E),c> (x : a, clause : (x : a, k : (b) -> (e :: E) c) -> (e :: E) c, k : ((resume-result :: (V, V) -> V)<b,c>) -> (e :: E) c) -> (e :: E) c;
fun protect.1 : forall<a,b,c,(e :: E),d> (x1 : a, x2 : b, clause : (x : a, x : b, k : (c) -> (e :: E) d) -> (e :: E) d, k : ((resume-result :: (V, V) -> V)<c,d>) -> (e :: E) d) -> (e :: E) d;
pub fun clause-control0 : forall<a,(e :: E),(b :: (E, V) -> V),c> (op : ((a) -> (e :: E) c) -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
pub fun clause-control1 : forall<a,b,(e :: E),(c :: (E, V) -> V),d> (clause : (x : a, k : (b) -> (e :: E) d) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
pub fun clause-control2 : forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> (clause : (x1 : a, x2 : b, k : (c) -> (e :: E) a1) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub fun clause-control3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (x1 : a, x2 : b, x3 : c, k : (d) -> (e :: E) b1) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub fun clause-control4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (x1 : a, x2 : b, x3 : c, x4 : d, k : (a1) -> (e :: E) c1) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
pub fun clause-never0 : forall<a,(e :: E),(b :: (E, V) -> V),c> (op : () -> (e :: E) c) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>;
pub fun clause-never1 : forall<a,b,(e :: E),(c :: (E, V) -> V),d> (op : (a) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>;
pub fun clause-never2 : forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> (op : (a, b) -> (e :: E) a1) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>;
pub fun clause-never3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (a, b, c) -> (e :: E) b1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub fun clause-never4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (a, b, c, d) -> (e :: E) c1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
pub fun clause-tail-noyield3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (a, b, c) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub fun clause-tail-noyield4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (a, b, c, d) -> (e :: E) a1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
// extra under1x to make under1 inlineable
fun under1x : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : (a) -> (e :: E) b, x : a) -> (e :: E) b;
fun under1 : forall<a,b,(e :: E),(c :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op : (a) -> (e :: E) b, x : a) -> (e :: E) b;
fun under0 : forall<a,(e :: E),(b :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op : () -> (e :: E) a) -> (e :: E) a;
pub fun clause-tail0 : forall<(e :: E),a,b,(c :: (E, V) -> V)> (op : () -> (e :: E) b) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<b,(c :: (E, V) -> V),(e :: E),a>;
pub fun clause-tail1 : forall<(e :: E),a,b,c,(d :: (E, V) -> V)> (op : (b) -> (e :: E) c) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<b,c,(d :: (E, V) -> V),(e :: E),a>;
fun under2 : forall<a,b,c,(e :: E),(d :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op : (a, b) -> (e :: E) c, x1 : a, x2 : b) -> (e :: E) c;
pub fun clause-tail2 : forall<(e :: E),a,b,c,d,(a1 :: (E, V) -> V)> (op : (b, c) -> (e :: E) d) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<b,c,d,(a1 :: (E, V) -> V),(e :: E),a>;
pub fun clause-tail3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V),b1> (op : (a, b, c) -> (e :: E) d) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c),d,(a1 :: (E, V) -> V),(e :: E),b1>;
pub fun clause-tail4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V),c1> (op : (a, b, c, d) -> (e :: E) a1) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<(a, b, c, d),a1,(b1 :: (E, V) -> V),(e :: E),c1>;
fun finally-prompt : forall<a,(e :: E)> (fin : () -> (e :: E) (), res : a) -> (e :: E) a;
pub fun finally : forall<a,(e :: E)> (fin : () -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
fun initially-prompt : forall<a,(e :: E)> (init : (std/core/types/int) -> (e :: E) (), res : a) -> (e :: E) a;
pub fun initially : forall<a,(e :: E)> (init : (std/core/types/int) -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
fun prompt-local-var : forall<a,b,(h :: H)> (loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>> b;
pub fun local-var : forall<a,b,(e :: E),(h :: H)> (init : a, action : (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b;
fun try-finalize-prompt : forall<a,(e :: E)> (res : a) -> (e :: E) (std/core/types/either :: (V, V) -> V)<yield-info,a>;
fun under3 : forall<a,b,c,d,(e :: E),(a1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, op : (a, b, c) -> (e :: E) d, x1 : a, x2 : b, x3 : c) -> (e :: E) d;
fun under4 : forall<a,b,c,d,a1,(e :: E),(b1 :: (E, V) -> V)> (ev : (ev :: ((E, V) -> V) -> V)<(b1 :: (E, V) -> V)>, op : (a, b, c, d) -> (e :: E) a1, x1 : a, x2 : b, x3 : c, x4 : d) -> (e :: E) a1;
pub fun unsafe-try-finalize : forall<a,(e :: E)> (action : () -> (e :: E) a) -> (e :: E) (std/core/types/either :: (V, V) -> V)<yield-info,a>;
pub fun yield-bind2 : forall<a,b,(e :: E)> (x : a, extend : (a) -> (e :: E) b, next : (a) -> (e :: E) b) -> (e :: E) b;
 
//------------------------------
//#kki: external declarations
 
extern evv-total : () -> (evv :: E -> V)<(std/core/types/(<>) :: E)> {
  c inline "kk_evv_total(kk_context())";
  js inline "[]";
};
pub extern .evv-at : forall<(a :: (E, V) -> V)> (i : ev-index) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> {
  c inline "kk_evv_at(#1,kk_context())";
  js inline "$std_core_hnd._evv_at(#1)";
};
pub extern .evv-select : forall<(a :: (E, V) -> V)> (i : ev-index, htag : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> {
  c inline "(#1 >= 0 ? kk_evv_at(#1,kk_context()) : kk_evv_lookup(#2,kk_context()))";
  js inline "(#1 >= 0 ? $std_core_hnd._evv_at(#1) : __evv_lookup(#2))";
};
extern evv-set : forall<(e :: E),(e1 :: E)> (w : (evv :: E -> V)<(e1 :: E)>) -> (e :: E) () {
  c inline "kk_evv_set(#1,kk_context())";
  js inline "$std_core_hnd._evv_set(#1)";
};
extern evv-swap : forall<(e :: E),(e1 :: E),(e2 :: E)> (w : (evv :: E -> V)<(e1 :: E)>) -> (e :: E) (evv :: E -> V)<(e2 :: E)> {
  c inline "kk_evv_swap(#1,kk_context())";
  js inline "$std_core_hnd._evv_swap(#1)";
};
extern evv-swap-create0 : forall<(e :: E)> () -> (e :: E) (evv :: E -> V)<(e :: E)> {
  c inline "kk_evv_swap_create0(kk_context())";
  js inline "$std_core_hnd._evv_swap_create0()";
};
extern evv-swap-create1 : forall<(e :: E)> (i : ev-index) -> (e :: E) (evv :: E -> V)<(e :: E)> {
  c inline "kk_evv_swap_create1(#1,kk_context())";
  js inline "$std_core_hnd._evv_swap_create1(#1)";
};
extern ev-none : forall<(e :: E),(a :: (E, V) -> V)> () -> (e :: E) (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> {
  c inline "kk_ev_none(kk_context())";
  js inline "ev_none()";
};
pub extern yielding : () -> std/core/types/bool {
  c inline "kk_yielding(kk_context())";
  js inline "$std_core_hnd._yielding()";
};
pub extern yielding-non-final : () -> std/core/types/bool {
  c inline "kk_yielding_non_final(kk_context())";
  js inline "$std_core_hnd._yielding_non_final()";
};
extern keep-yielding-final : forall<(e :: E),a> () -> (e :: E) a {
  c inline "kk_box_any(kk_context())";
  js inline "undefined";
};
extern cast-ev0 : forall<a,(e :: E),(e1 :: E)> (f : () -> (e1 :: E) a) -> (() -> (e :: E) a) = inline "#1";
extern cast-ev1 : forall<a,b,(e :: E),(e1 :: E)> (f : (a) -> (e1 :: E) b) -> ((a) -> (e :: E) b) = inline "#1";
extern cast-ev2 : forall<a,b,c,(e :: E),(e1 :: E)> (f : (a, b) -> (e1 :: E) c) -> ((a, b) -> (e :: E) c) = inline "#1";
extern cast-ev3 : forall<a,b,c,d,(e :: E),(e1 :: E)> (f : (a, b, c) -> (e1 :: E) d) -> ((a, b, c) -> (e :: E) d) = inline "#1";
extern cast-ev4 : forall<a,b,c,d,a1,(e :: E),(e1 :: E)> (f : (a, b, c, d) -> (e1 :: E) a1) -> ((a, b, c, d) -> (e :: E) a1) = inline "#1";
extern cast-ev5 : forall<a,b,c,d,a1,b1,(e :: E),(e1 :: E)> (f : (a, b, c, d, a1) -> (e1 :: E) b1) -> ((a, b, c, d, a1) -> (e :: E) b1) = inline "#1";
// add integers
extern add : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_add(#1,#2,kk_context())";
  cs inline "(#1 + #2)";
  js inline "(#1 + #2)";
};
// are two integers equal?
extern eq : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_eq_borrow(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "(#1 == #2)";
};
extern cast-ev0.1 : forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> (f : ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) = inline "#1";
extern cast-ev1.1 : forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> (f : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) = inline "#1";
extern cast-ev2.1 : forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> (f : ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) -> (e :: E) (((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) = inline "#1";
extern unsafe-st : forall<a,(e :: E)> (f : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>|(e :: E)> a) -> (() -> (e :: E) a) = inline "#1";
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
inline borrow "^" fun tagname // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(htag0: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (htag0) {
      ((.skip std/core/hnd/Htag((.x: std/core/types/string) : std/core/types/string) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat: ((htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> .x;
    });
  };
fun .copy // inline size: 2
  = forall<(a :: (E, V) -> V)> fn(.this: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, tagname0: (std/core/types/optional :: V -> V)<std/core/types/string>){
    std/core/hnd/Htag<(a :: (E, V) -> V)>((match (tagname0) {
      ((std/core/types/Optional((.tagname.2006: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/string>))
         -> .tagname.2006;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/string>))
         -> (match (.this) {
          ((.skip std/core/hnd/Htag((.x: std/core/types/string) : std/core/types/string) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat1: ((htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun m // inline size: 0
  = forall<(e :: E),a> fn(marker: (marker :: (E, V) -> V)<(e :: E),a>){
    (match (marker) {
      ((.skip std/core/hnd/Marker((.x: std/core/types/int32) : std/core/types/int32) : (marker :: (E, V) -> V)<(e :: E),a> ) as .pat: ((marker :: (E, V) -> V)<(e :: E),a>))
         -> .x;
    });
  };
fun .copy.1 // inline size: 2
  = forall<(e :: E),a> fn(.this: (marker :: (E, V) -> V)<(e :: E),a>, m0: (std/core/types/optional :: V -> V)<std/core/types/int32>){
    std/core/hnd/Marker<(e :: E),a>((match (m0) {
      ((std/core/types/Optional((.m.2042: std/core/types/int32) : std/core/types/int32) : (std/core/types/optional :: V -> V)<std/core/types/int32> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int32>))
         -> .m.2042;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int32> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int32>))
         -> (match (.this) {
          ((.skip std/core/hnd/Marker((.x: std/core/types/int32) : std/core/types/int32) : (marker :: (E, V) -> V)<(e :: E),a> ) as .pat1: ((marker :: (E, V) -> V)<(e :: E),a>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun htag // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(ev: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e :: E),b>((.x: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (.pat0: (marker :: (E, V) -> V)<(e :: E),b>) : (marker :: (E, V) -> V)<(e :: E),b>, (.pat1: (a :: (E, V) -> V)<(e :: E),b>) : (a :: (E, V) -> V)<(e :: E),b>, (.pat2: cfc) : cfc, (.pat3: (evv :: E -> V)<(e :: E)>) : (evv :: E -> V)<(e :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> .x;
    });
  };
inline borrow "^" fun cfc // inline size: 0
  = forall<(a :: (E, V) -> V)> fn(ev: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e :: E),b>((.pat0: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (.pat1: (marker :: (E, V) -> V)<(e :: E),b>) : (marker :: (E, V) -> V)<(e :: E),b>, (.pat2: (a :: (E, V) -> V)<(e :: E),b>) : (a :: (E, V) -> V)<(e :: E),b>, (.x: cfc) : cfc, (.pat3: (evv :: E -> V)<(e :: E)>) : (evv :: E -> V)<(e :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> .x;
    });
  };
fun .copy.2 // inline size: 3
  = forall<(a :: (E, V) -> V),(e :: E),b> fn(.this: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, htag0: (std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>, marker: (marker :: (E, V) -> V)<(e :: E),b>, hnd: (a :: (E, V) -> V)<(e :: E),b>, cfc0: (std/core/types/optional :: V -> V)<cfc>, hevv: (evv :: E -> V)<(e :: E)>){
    std/core/hnd/Ev<(a :: (E, V) -> V),(e :: E),b>((match (htag0) {
        ((std/core/types/Optional((.htag.2119: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>> ) as .pat: ((std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>))
           -> .htag.2119;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>> ) as .pat0: ((std/core/types/optional :: V -> V)<(htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>>))
           -> (match (.this) {
            ((.skip std/core/hnd/Ev<(e1 :: E),c>((.x: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (.pat00: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (.pat10: (a :: (E, V) -> V)<(e1 :: E),c>) : (a :: (E, V) -> V)<(e1 :: E),c>, (.pat2: cfc) : cfc, (.pat3: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat1: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
               -> .x;
          });
      }), marker, hnd, (match (cfc0) {
        ((std/core/types/Optional((.cfc.2126: cfc) : cfc) : (std/core/types/optional :: V -> V)<cfc> ) as .pat11: ((std/core/types/optional :: V -> V)<cfc>))
           -> .cfc.2126;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<cfc> ) as .pat20: ((std/core/types/optional :: V -> V)<cfc>))
           -> (match (.this) {
            ((.skip std/core/hnd/Ev<(e1 :: E),c>((.pat01: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (.pat12: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (.pat21: (a :: (E, V) -> V)<(e1 :: E),c>) : (a :: (E, V) -> V)<(e1 :: E),c>, (.x0: cfc) : cfc, (.pat30: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat4: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
               -> .x0;
          });
      }), hevv);
  };
inline borrow "^" fun clause // inline size: 0
  = forall<a,(b :: (E, V) -> V),(e :: E),c> fn(clause0: (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>){
    (match (clause0) {
      ((.skip std/core/hnd/Clause0((.x: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c> ) as .pat: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>))
         -> .x;
    });
  };
fun .copy.3 // inline size: 2
  = forall<a,(b :: (E, V) -> V),(e :: E),c> fn(.this: (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>, clause0: (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((match (clause0) {
      ((std/core/types/Optional((.clause.2218: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a> ) as .pat: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>))
         -> .clause.2218;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a> ) as .pat0: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a>))
         -> (match (.this) {
          ((.skip std/core/hnd/Clause0((.x: ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : ((marker :: (E, V) -> V)<(e :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c> ) as .pat1: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e :: E),c>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun clause.1 // inline size: 0
  = forall<a,b,(c :: (E, V) -> V),(e :: E),d> fn(clause1: (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>){
    (match (clause1) {
      ((.skip std/core/hnd/Clause1((.x: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d> ) as .pat: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>))
         -> .x;
    });
  };
fun .copy.4 // inline size: 2
  = forall<a,b,(c :: (E, V) -> V),(e :: E),d> fn(.this: (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>, clause0: (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((match (clause0) {
      ((std/core/types/Optional((.clause.2420: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b> ) as .pat: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>))
         -> .clause.2420;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b> ) as .pat0: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b>))
         -> (match (.this) {
          ((.skip std/core/hnd/Clause1((.x: ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : ((marker :: (E, V) -> V)<(e :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d> ) as .pat1: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e :: E),d>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun clause.2 // inline size: 0
  = forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> fn(clause2: (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>){
    (match (clause2) {
      ((.skip std/core/hnd/Clause2((.x: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1> ) as .pat: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>))
         -> .x;
    });
  };
fun .copy.5 // inline size: 2
  = forall<a,b,c,(d :: (E, V) -> V),(e :: E),a1> fn(.this: (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>, clause0: (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((match (clause0) {
      ((std/core/types/Optional((.clause.2717: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c> ) as .pat: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>))
         -> .clause.2717;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c> ) as .pat0: ((std/core/types/optional :: V -> V)<((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c>))
         -> (match (.this) {
          ((.skip std/core/hnd/Clause2((.x: ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : ((marker :: (E, V) -> V)<(e :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1> ) as .pat1: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e :: E),a1>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun is-deep // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Deep((.pat0: a) : a) : (resume-result :: (V, V) -> V)<a,b> ) as .pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (.pat1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-shallow // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Shallow((.pat0: a) : a) : (resume-result :: (V, V) -> V)<a,b> ) as .pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (.pat1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-finalize // inline size: 1
  = forall<a,b> fn(resume-result: (resume-result :: (V, V) -> V)<a,b>){
    (match (resume-result) {
      ((std/core/hnd/Finalize((.pat0: b) : b) : (resume-result :: (V, V) -> V)<a,b> ) as .pat: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/True;
      (.pat1: ((resume-result :: (V, V) -> V)<a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun k // inline size: 0
  = forall<a,(e :: E),(e1 :: E),b> fn(.this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>){
    (match (.this) {
      ((.skip std/core/hnd/Resume-context((.x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as .pat: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
         -> .x;
    });
  };
fun .copy.6 // inline size: 2
  = forall<a,(e :: E),(e1 :: E),b> fn(.this: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, k0: (std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>){
    std/core/hnd/Resume-context<a,(e :: E),(e1 :: E),b>((match (k0) {
      ((std/core/types/Optional((.k.2940: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b> ) as .pat: ((std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>))
         -> .k.2940;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b> ) as .pat0: ((std/core/types/optional :: V -> V)<((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b>))
         -> (match (.this) {
          ((.skip std/core/hnd/Resume-context((.x: ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : ((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b) : (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b> ) as .pat1: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun is-pure // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Pure() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as .pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (.pat0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-yieldingFinal // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/YieldingFinal() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as .pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (.pat0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-yielding // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Yielding() : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as .pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (.pat0: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-yield // inline size: 1
  = forall<a,b,(e :: E)> fn(yld: (yld :: (E, V, V) -> V)<(e :: E),a,b>){
    (match (yld) {
      ((std/core/hnd/Yield<c>((.pat0: (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b) : (((resume-result :: (V, V) -> V)<c,b>) -> (e :: E) b) -> (e :: E) b, (.pat1: (() -> c) -> (e :: E) a) : (() -> c) -> (e :: E) a) : (yld :: (E, V, V) -> V)<(e :: E),a,b> ) as .pat: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/True;
      (.pat2: ((yld :: (E, V, V) -> V)<(e :: E),a,b>))
         -> std/core/types/False;
    });
  };
fun .mask-builtin // inline size: 3
  = forall<a,(e :: E),(e1 :: E)> fn<(e1 :: E)>(action: () -> (e :: E) a){
    std/core/types/.open<(std/core/types/(<>) :: E),(e1 :: E),(f : () -> (e :: E) a) -> (() -> (e1 :: E) a),(f : () -> (e :: E) a) -> (e1 :: E) (() -> (e1 :: E) a)>((std/core/hnd/cast-ev0<a,(e1 :: E),(e :: E)>))(action)();
  };
fun .new-htag // inline size: 1
  = forall<(a :: (E, V) -> V)> fn(tag: std/core/types/string){
    std/core/hnd/Htag<(a :: (E, V) -> V)>(tag);
  };
inline fun .perform0 // inline size: 4
  = forall<a,(e :: E),(b :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op: forall<(e1 :: E),c> ((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e1 :: E),c>((.pat0: (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, (m0: (marker :: (E, V) -> V)<(e1 :: E),c>) : (marker :: (E, V) -> V)<(e1 :: E),c>, (h: (b :: (E, V) -> V)<(e1 :: E),c>) : (b :: (E, V) -> V)<(e1 :: E),c>, (.pat1: cfc) : cfc, (.pat2: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>))
         -> (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((b :: (E, V) -> V)<(e1 :: E),c>) -> (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>,((b :: (E, V) -> V)<(e1 :: E),c>) -> (e :: E) (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>>((op<(e1 :: E),c>))(h))) {
          ((.skip std/core/hnd/Clause0((f: ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) : ((marker :: (E, V) -> V)<(e1 :: E),c>, (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e1 :: E) a) : (clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c> ) as .pat3: ((clause0 :: (V, (E, V) -> V, E, V) -> V)<a,(b :: (E, V) -> V),(e1 :: E),c>))
             -> std/core/hnd/cast-ev0.1<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c>(f)(m0, ev);
        });
    });
  };
inline fun .perform1 // inline size: 4
  = forall<a,b,(e :: E),(c :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x: a){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e1 :: E),d>((.pat0: (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, (m0: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (h: (c :: (E, V) -> V)<(e1 :: E),d>) : (c :: (E, V) -> V)<(e1 :: E),d>, (.pat1: cfc) : cfc, (.pat2: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>))
         -> (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>,((c :: (E, V) -> V)<(e1 :: E),d>) -> (e :: E) (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>>((op<(e1 :: E),d>))(h))) {
          ((.skip std/core/hnd/Clause1((f: ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d> ) as .pat3: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>))
             -> std/core/hnd/cast-ev1.1<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d>(f)(m0, ev, x);
        });
    });
  };
inline fun .perform2 // inline size: 4
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V)> fn<(e :: E)>(evx: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, op: forall<(e1 :: E),a1> ((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>, x: a, y: b){
    (match (evx) {
      ((.skip std/core/hnd/Ev<(e1 :: E),a1>((.pat0: (htag :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, (m0: (marker :: (E, V) -> V)<(e1 :: E),a1>) : (marker :: (E, V) -> V)<(e1 :: E),a1>, (h: (d :: (E, V) -> V)<(e1 :: E),a1>) : (d :: (E, V) -> V)<(e1 :: E),a1>, (.pat1: cfc) : cfc, (.pat2: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>))
         -> (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((d :: (E, V) -> V)<(e1 :: E),a1>) -> (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>,((d :: (E, V) -> V)<(e1 :: E),a1>) -> (e :: E) (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>>((op<(e1 :: E),a1>))(h))) {
          ((.skip std/core/hnd/Clause2((f: ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) : ((marker :: (E, V) -> V)<(e1 :: E),a1>, (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, a, b) -> (e1 :: E) c) : (clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1> ) as .pat3: ((clause2 :: (V, V, V, (E, V) -> V, E, V) -> V)<a,b,c,(d :: (E, V) -> V),(e1 :: E),a1>))
             -> std/core/hnd/cast-ev2.1<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1>(f)(m0, evx, x, y);
        });
    });
  };
fun xperform1 // inline size: 4
  = forall<a,b,(e :: E),(c :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: forall<(e1 :: E),d> ((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>, x: a){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e1 :: E),d>((.pat0: (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, (m0: (marker :: (E, V) -> V)<(e1 :: E),d>) : (marker :: (E, V) -> V)<(e1 :: E),d>, (h: (c :: (E, V) -> V)<(e1 :: E),d>) : (c :: (E, V) -> V)<(e1 :: E),d>, (.pat1: cfc) : cfc, (.pat2: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>))
         -> (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((c :: (E, V) -> V)<(e1 :: E),d>) -> (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>,((c :: (E, V) -> V)<(e1 :: E),d>) -> (e :: E) (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>>((op<(e1 :: E),d>))(h))) {
          ((.skip std/core/hnd/Clause1((f: ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : ((marker :: (E, V) -> V)<(e1 :: E),d>, (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, a) -> (e1 :: E) b) : (clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d> ) as .pat3: ((clause1 :: (V, V, (E, V) -> V, E, V) -> V)<a,b,(c :: (E, V) -> V),(e1 :: E),d>))
             -> std/core/hnd/cast-ev1.1<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d>(f)(m0, ev, x);
        });
    });
  };
fun clause-tail-noyield0 // inline size: 2
  = forall<(e :: E),a,b,(c :: (E, V) -> V)> fn(op: () -> (e :: E) b){
    std/core/hnd/Clause0<b,(c :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(._wildcard_565_14: (marker :: (E, V) -> V)<(e :: E),a>, ._wildcard_565_17: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>){
      (op());
    }));
  };
fun clause-tail-noyield1 // inline size: 2
  = forall<(e :: E),a,b,c,(d :: (E, V) -> V)> fn(op: (b) -> (e :: E) c){
    std/core/hnd/Clause1<b,c,(d :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(._wildcard_522_14: (marker :: (E, V) -> V)<(e :: E),a>, ._wildcard_522_17: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x: b){
      (op(x));
    }));
  };
fun clause-tail-noyield2 // inline size: 2
  = forall<(e :: E),a,b,c,d,(a1 :: (E, V) -> V)> fn(op: (b, c) -> (e :: E) d){
    std/core/hnd/Clause2<b,c,d,(a1 :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(._wildcard_607_14: (marker :: (E, V) -> V)<(e :: E),a>, ._wildcard_607_17: (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, x1: b, x2: c){
      (op(x1, x2));
    }));
  };
fun evv-swap-with // inline size: 1
  = forall<(a :: (E, V) -> V),(e :: E)> fn(ev: (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>){
    (match (ev) {
      ((.skip std/core/hnd/Ev<(e1 :: E),b>((.pat0: (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>) : (htag :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>, (.pat1: (marker :: (E, V) -> V)<(e1 :: E),b>) : (marker :: (E, V) -> V)<(e1 :: E),b>, (.pat2: (a :: (E, V) -> V)<(e1 :: E),b>) : (a :: (E, V) -> V)<(e1 :: E),b>, (.pat3: cfc) : cfc, (w: (evv :: E -> V)<(e1 :: E)>) : (evv :: E -> V)<(e1 :: E)>) : (ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)> ) as .pat: ((ev :: ((E, V) -> V) -> V)<(a :: (E, V) -> V)>))
         -> std/core/hnd/evv-swap<(std/core/types/(<>) :: E),(e1 :: E),(e :: E)>(w);
    });
  };
fun clause-value // inline size: 1
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(v: a){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(._wildcard_568_14: (marker :: (E, V) -> V)<(e :: E),c>, ._wildcard_568_17: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      v;
    }));
  };
fun get // inline size: 1
  = forall<a,(h :: H)> fn<<(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/div :: X)>>(ref: (std/core/types/ref :: (H, V) -> V)<(h :: H),a>){
    std/core/types/(!)<(h :: H),a,<(std/core/types/div :: E)>>(ref);
  };
fun hidden-htag // inline size: 1
  = forall<(a :: (E, V) -> V)> fn(tag: std/core/types/string){
    std/core/hnd/Htag<(a :: (E, V) -> V)>(tag);
  };
fun resume // inline size: 4
  = forall<a,(e :: E),(e1 :: E),b> fn<(e :: E)>(r: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x: a){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (e :: E) (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b)>((std/core/hnd/k<a,(e :: E),(e1 :: E),b>))(r)((std/core/hnd/Deep<a,b>(x)));
  };
fun fresh-marker // inline size: 2
  = forall<(e :: E),a> fn(){
    std/core/hnd/Marker<(e :: E),a>((std/core/hnd/fresh-marker-int()));
  };
inline fun yield-bind // inline size: 0
  = forall<a,b,(e :: E)> fn<(e :: E)>(x: a, next: (a) -> (e :: E) b){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<a,b,(e :: E)>(next);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> next(x);
    });
  };
fun fresh-marker-named // inline size: 2
  = forall<(e :: E),a> fn(){
    std/core/hnd/Marker<(e :: E),a>((std/core/hnd/fresh-marker-named-int()));
  };
fun clause-control-raw0 // inline size: 4
  = forall<a,(e :: E),(e1 :: E),(b :: (E, V) -> V),c> fn(op: ((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),c>) -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),c>, ._wildcard_550_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to<a,(e :: E),c>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (op((std/core/hnd/Resume-context<a,(e :: E),(e1 :: E),c>(k0))));
        })));
    }));
  };
fun clause-control-raw1 // inline size: 4
  = forall<a,b,(e :: E),(e1 :: E),(c :: (E, V) -> V),d> fn(op: (x : a, r : (resume-context :: (V, E, E, V) -> V)<b,(e :: E),(e1 :: E),d>) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),d>, ._wildcard_487_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to<b,(e :: E),d>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (op(x, (std/core/hnd/Resume-context<b,(e :: E),(e1 :: E),d>(k0))));
        })));
    }));
  };
fun clause-control-raw2 // inline size: 4
  = forall<a,b,c,(e :: E),(e1 :: E),(d :: (E, V) -> V),a1> fn(op: (x1 : a, x2 : b, r : (resume-context :: (V, E, E, V) -> V)<c,(e :: E),(e1 :: E),a1>) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),a1>, ._wildcard_601_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to<c,(e :: E),a1>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (op(x1, x2, (std/core/hnd/Resume-context<c,(e :: E),(e1 :: E),a1>(k0))));
        })));
    }));
  };
fun finalize // inline size: 4
  = forall<a,(e :: E),(e1 :: E),b> fn<(e :: E)>(r: (resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>, x: b){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b),((resume-context :: (V, E, E, V) -> V)<a,(e :: E),(e1 :: E),b>) -> (e :: E) (((resume-result :: (V, V) -> V)<a,b>) -> (e :: E) b)>((std/core/hnd/k<a,(e :: E),(e1 :: E),b>))(r)((std/core/hnd/Finalize<a,b>(x)));
  };
fun clause-control0 // inline size: 4
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(op: ((a) -> (e :: E) c) -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),c>, ._wildcard_558_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to<a,(e :: E),c>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (std/core/hnd/protect<(),a,(e :: E),c>(std/core/types/(), (fn<(e :: E)>(._wildcard_558_55: (), r: (a) -> (e :: E) c){
              (op(r));
            }), k0));
        })));
    }));
  };
fun clause-control1 // inline size: 3
  = forall<a,b,(e :: E),(c :: (E, V) -> V),d> fn(clause0: (x : a, k : (b) -> (e :: E) d) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),d>, ._wildcard_516_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to<b,(e :: E),d>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (std/core/hnd/protect<a,b,(e :: E),d>(x, clause0, k0));
        })));
    }));
  };
fun clause-control2 // inline size: 3
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> fn(clause0: (x1 : a, x2 : b, k : (c) -> (e :: E) a1) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),a1>, ._wildcard_597_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to<c,(e :: E),a1>(m0, (fn<(e :: E)>(k0: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (std/core/hnd/protect.1<a,b,c,(e :: E),a1>(x1, x2, clause0, k0));
        })));
    }));
  };
fun clause-never0 // inline size: 3
  = forall<a,(e :: E),(b :: (E, V) -> V),c> fn(op: () -> (e :: E) c){
    std/core/hnd/Clause0<a,(b :: (E, V) -> V),(e :: E),c>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),c>, ._wildcard_571_16: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>){
      (std/core/hnd/yield-to-final<a,(e :: E),(e :: E),c>(m0, (fn<(e :: E)>(._wildcard_571_43: ((resume-result :: (V, V) -> V)<a,c>) -> (e :: E) c){
          (op());
        })));
    }));
  };
fun clause-never1 // inline size: 3
  = forall<a,b,(e :: E),(c :: (E, V) -> V),d> fn(op: (a) -> (e :: E) d){
    std/core/hnd/Clause1<a,b,(c :: (E, V) -> V),(e :: E),d>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),d>, ._wildcard_525_16: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, x: a){
      (std/core/hnd/yield-to-final<b,(e :: E),(e :: E),d>(m0, (fn<(e :: E)>(._wildcard_525_45: ((resume-result :: (V, V) -> V)<b,d>) -> (e :: E) d){
          (op(x));
        })));
    }));
  };
fun clause-never2 // inline size: 3
  = forall<a,b,c,(e :: E),(d :: (E, V) -> V),a1> fn(op: (a, b) -> (e :: E) a1){
    std/core/hnd/Clause2<a,b,c,(d :: (E, V) -> V),(e :: E),a1>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),a1>, ._wildcard_615_16: (ev :: ((E, V) -> V) -> V)<(d :: (E, V) -> V)>, x1: a, x2: b){
      (std/core/hnd/yield-to-final<c,(e :: E),(e :: E),a1>(m0, (fn<(e :: E)>(._wildcard_615_49: ((resume-result :: (V, V) -> V)<c,a1>) -> (e :: E) a1){
          (op(x1, x2));
        })));
    }));
  };
inline fun under1 // inline size: 11
  = forall<a,b,(e :: E),(c :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>, op: (a) -> (e :: E) b, x: a){
    val w0 : (evv :: E -> V)<(_e1 :: E)>
      = std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((std/core/hnd/evv-swap-with<(c :: (E, V) -> V),(_e1 :: E)>))(ev);
    val y : b
      = op(x);
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-cont<b,(e :: E),b>((forall<d> fn<(e :: E)>(cont: (d) -> (e :: E) b, res: d){
          std/core/hnd/under1x<d,b,(e :: E),(c :: (E, V) -> V)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>,(x : (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>) -> (e :: E) (ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>>((std/core/types/unsafe-decreasing<(ev :: ((E, V) -> V) -> V)<(c :: (E, V) -> V)>>))(ev)), cont, res);
        }));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val _0 : ()
                  = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w0);
        y;
    });
  };
inline fun under0 // inline size: 19
  = forall<a,(e :: E),(b :: (E, V) -> V)> fn<(e :: E)>(ev: (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>, op: () -> (e :: E) a){
    val w0 : (evv :: E -> V)<(_e1 :: E)>
      = std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((std/core/hnd/evv-swap-with<(b :: (E, V) -> V),(_e1 :: E)>))(ev);
    val y : a
      = op();
    val _ : ()
      = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w0);
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-cont<a,(e :: E),a>((forall<c> fn<(e :: E)>(cont: (c) -> (e :: E) a, res: c){
          val w00 : (evv :: E -> V)<(_e1 :: E)>
            = std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (evv :: E -> V)<(_e1 :: E)>,(ev : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (evv :: E -> V)<(_e1 :: E)>>((std/core/hnd/evv-swap-with<(b :: (E, V) -> V),(_e1 :: E)>))(ev);
          val y0 : a
            = cont(res);
          (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
            ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
               -> std/core/hnd/yield-cont<a,(e :: E),a>((forall<d> fn<(e :: E)>(cont0: (d) -> (e :: E) a, res0: d){
                std/core/hnd/under1x<d,a,(e :: E),(b :: (E, V) -> V)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>,(x : (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>) -> (e :: E) (ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>>((std/core/types/unsafe-decreasing<(ev :: ((E, V) -> V) -> V)<(b :: (E, V) -> V)>>))(ev)), cont0, res0);
              }));
            ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
               -> val _0 : ()
                        = std/core/hnd/evv-set<(e :: E),(_e1 :: E)>(w00);
              y0;
          });
        }));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
         -> y;
    });
  };
fun clause-tail2 // inline size: 2
  = forall<(e :: E),a,b,c,d,(a1 :: (E, V) -> V)> fn(op: (b, c) -> (e :: E) d){
    std/core/hnd/Clause2<b,c,d,(a1 :: (E, V) -> V),(e :: E),a>((fn<(e :: E)>(m0: (marker :: (E, V) -> V)<(e :: E),a>, ev: (ev :: ((E, V) -> V) -> V)<(a1 :: (E, V) -> V)>, x1: b, x2: c){
      (std/core/hnd/under2<b,c,d,(e :: E),(a1 :: (E, V) -> V)>(ev, op, x1, x2));
    }));
  };
fun finally // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(fin: () -> (e :: E) (), action: () -> (e :: E) a){
    std/core/hnd/finally-prompt<a,(e :: E)>(fin, (action()));
  };
inline fun local-var // inline size: 10
  = forall<a,b,(e :: E),(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(init: a, action: (l : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b){
    std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,() -> b,() -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b>((std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(action : () -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> (() -> b),(action : () -> <(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (() -> b)>((std/core/types/unsafe-total-cast<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,b>))((fn<<(std/core/types/div :: X),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      val loc : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>)
        = (std/core/types/local-new<a,<(std/core/types/div :: E)|(e :: E)>,(h :: H)>(init));
      val res : b
        = (std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(f : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> (((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b),(f : ((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> (((std/core/types/local-var :: (H, V) -> V)<(h :: H),a>) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b)>((std/core/hnd/cast-ev1<(std/core/types/local-var :: (H, V) -> V)<(h :: H),a>,b,<(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>))(action)(loc));
      (std/core/types/.open<<(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>>,<(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>> b,(loc : (std/core/types/local-var :: (H, V) -> V)<(h :: H),a>, res : b) -> <(std/core/types/div :: E),(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> b>((std/core/hnd/prompt-local-var<a,b,(h :: H)>))(loc, res));
    }))))();
  };
fun unsafe-try-finalize // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> (e :: E) a){
    std/core/hnd/try-finalize-prompt<a,(e :: E)>((action()));
  };
inline fun yield-bind2 // inline size: 0
  = forall<a,b,(e :: E)> fn<(e :: E)>(x: a, extend: (a) -> (e :: E) b, next: (a) -> (e :: E) b){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),() -> std/core/types/bool,() -> (e :: E) std/core/types/bool>(std/core/hnd/yielding)())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/hnd/yield-extend<a,b,(e :: E)>(extend);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> next(x);
    });
  };