/* Core functions.

   This module is implicitly imported and all functions and types
   are always available.
   Some types and operations are required to be defined for the compiler
   to work correctly (i.e. types like `:exn` or `:list`)
*/
module interface std/core
 
//------------------------------
//#kki: import declarations
 
pub import std/core/types = std/core/types = "";
pub import std/core/hnd = std/core/hnd = "";
 
//------------------------------
//#kki: external imports
 
 
//------------------------------
//#kki: fixity declarations
 
infixr 80 (^);
infixl 70 (*);
infixl 70 (%);
infixl 70 (/);
infixl 70 cdiv;
infixl 70 cmod;
infixr 60 (++);
infixl 60 (+);
infixl 60 (-);
infix 40 (!=);
infix 40 (==);
infix 40 (<=);
infix 40 (>=);
infix 40 (<);
infix 40 (>);
 
//------------------------------
//#kki: local imported aliases
 
// Stateful functions can manipulate heap `:h` using allocations, reads and writes.
local alias std/core/types/st<(h :: H)> :: H -> E = <(std/core/types/read :: H -> X)<(h :: H)>,(std/core/types/write :: H -> X)<(h :: H)>,(std/core/types/alloc :: H -> X)<(h :: H)>> = 1;
 
//------------------------------
//#kki: type declarations
 
// Exception information
pub open type exception-info {
  pub con ExnError : exception-info;
  pub con ExnAssert : exception-info;
  pub con ExnTodo : exception-info;
  pub con ExnRange : exception-info;
  pub con ExnPattern(location: std/core/types/string, definition: std/core/types/string) : (location : std/core/types/string, definition : std/core/types/string) -> exception-info;
  pub con ExnSystem(errno: std/core/types/int) : (errno : std/core/types/int) -> exception-info;
  pub con ExnInternal(name: std/core/types/string) : (name : std/core/types/string) -> exception-info;
};
// The exception data type
pub value{0,2} type exception {
  // The exception data type
  pub con Exception(message: std/core/types/string, info: exception-info) : (message : std/core/types/string, info : exception-info) -> exception;
};
// handlers for the `:exn` effect
pub recursive type .hnd-exn <(e :: E),a> :: (E, V) -> V {
  pub con .Hnd-exn(ctl-throw-exn: forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,b,(.hnd-exn :: (E, V) -> V),(e :: E),a>) : forall<(e :: E),a> (ctl-throw-exn : forall<b> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,b,(.hnd-exn :: (E, V) -> V),(e :: E),a>) -> (.hnd-exn :: (E, V) -> V)<(e :: E),a>;
};
// The `:blocking` effect signifies that a function may block
pub type blocking :: X ;
// The console effect signifies that a function may write to the console.
pub type console :: X ;
// Delayed (or _lazy_) values are computed (with effect `:e`) only the first time
// `force` is called and cached afterwards.
pub value{0,1} type delayed <(e :: E),a> :: (E, V) -> V {
  con Delay(dref: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : forall<(e :: E),a> (dref : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) -> (delayed :: (E, V) -> V)<(e :: E),a>;
};
// An `:error` type represents a first-class exception result.
pub value{0,2} type error <a> :: V -> V {
  pub con Error(exception: exception) : forall<a> (exception : exception) -> (error :: V -> V)<a>;
  pub con Ok(result: a) : forall<a> (result : a) -> (error :: V -> V)<a>;
};
// Exceptions
pub type exn :: HX {
  con Exn<(e :: E),a>((.hnd-exn :: (E, V) -> V)<(e :: E),a>) : forall<(e :: E),a> ((.hnd-exn :: (E, V) -> V)<(e :: E),a>) -> (exn :: HX);
};
// The `:fsys` effect signifies a function may access the file system
pub type fsys :: X ;
// The `:global-scope` is a special type constant to denote the global scope
pub type global-scope :: S ;
// The `:net` effect signifies a function may access the network
pub type net :: X ;
// The `:ui` effect signifies a function may access the graphics system
pub type ui :: X ;
// The `:io-total` effect is used for functions that perform arbitrary I/O operations, but are terminating without raising exceptions.
pub alias io-total :: E = <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)> = 2;
// The `:io-noexn` effect is used for functions that perform arbitrary I/O operations, but raise no exceptions
pub alias io-noexn :: E = <(std/core/types/div :: X),((io-total :: E) == 2 <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)> = 3;
// The `:io` effect is used for functions that perform arbitrary I/O operations.
pub alias io :: E = <(std/core/types/handled :: HX -> X)<(exn :: HX)>,((io-noexn :: E) == 3 <(std/core/types/div :: X),((io-total :: E) == 2 <(std/core/types/ndet :: X),(console :: X),(net :: X),(fsys :: X),(ui :: X),((std/core/types/st :: H -> E)<(std/core/types/global :: H)> == 1 <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>,(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>>)>)>)> = 4;
// The type of lists, which can be either empty (`Nil`) or an element followed
// by a list (`Cons`).
pub recursive type list <a> :: V -> V {
  // The empty list.
  pub con Nil : forall<a> (list :: V -> V)<a>;
  // A ``head``  element followed by the ``tail``  of the list.
  pub con Cons(head: a, tail: (list :: V -> V)<a>) : forall<a> (head : a, tail : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
};
// The `:named` effect is the default umbrella effect for named effects
pub type nmd :: X ;
// Abstract type used for passing `null` values to external functions
pub type null <a> :: V -> V ;
// An alias for pure effects: a pure function always returns the same result
// when called with the same arguments but may not terminate or raise an exception.
pub alias pure :: E = <(std/core/types/handled :: HX -> X)<(exn :: HX)>,(std/core/types/div :: X)> = 1;
pub type scope <(s :: S)> :: S -> X ;
// A `:sslice` represents a sub-slice of string and
// has a specific start position and character count. It is used
// instead of string indices to make the actual internal representation
// of strings abstract (like UTF-8 or UTF-16). String slices are
// returned by functions that find sub strings or patterns in
// in strings. Use `string:(slice : sslice) -> string` to
// create a fresh substring from a slice.
pub value{16,1} type sslice {
  // A `:sslice` represents a sub-slice of string and
// has a specific start position and character count. It is used
// instead of string indices to make the actual internal representation
// of strings abstract (like UTF-8 or UTF-16). String slices are
// returned by functions that find sub strings or patterns in
// in strings. Use `string:(slice : sslice) -> string` to
// create a fresh substring from a slice.
  con Sslice(str: std/core/types/string, start: std/core/types/ssize_t, len: std/core/types/ssize_t) : (str : std/core/types/string, start : std/core/types/ssize_t, len : std/core/types/ssize_t) -> sslice;
};
// A `:stream` is a co-inductive type representing an infinite list of elements.
pub recursive co type stream <a> :: V -> V {
  pub con Next(head: a, tail: (stream :: V -> V)<a>) : forall<a> (head : a, tail : (stream :: V -> V)<a>) -> (stream :: V -> V)<a>;
};
// An alias for the empty effect.
pub alias total :: E = (std/core/types/(<>) :: E) = 1;
// Internal: used for value effects
// TODO: revisit value effects codegen
pub alias value<a> :: V -> V = a = 1;
 
//------------------------------
//#kki: declarations
 
// Automatically generated. Tests for the `ExnError` constructor of the `:exception-info` type.
pub fun is-exnError : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnAssert` constructor of the `:exception-info` type.
pub fun is-exnAssert : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnTodo` constructor of the `:exception-info` type.
pub fun is-exnTodo : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnRange` constructor of the `:exception-info` type.
pub fun is-exnRange : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnPattern` constructor of the `:exception-info` type.
pub fun is-exnPattern : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnSystem` constructor of the `:exception-info` type.
pub fun is-exnSystem : (^ exception-info : exception-info) -> std/core/types/bool;
// Automatically generated. Tests for the `ExnInternal` constructor of the `:exception-info` type.
pub fun is-exnInternal : (^ exception-info : exception-info) -> std/core/types/bool;
pub val .tag-ExnError : std/core/types/string;
pub val .tag-ExnAssert : std/core/types/string;
pub val .tag-ExnTodo : std/core/types/string;
pub val .tag-ExnRange : std/core/types/string;
pub val .tag-ExnPattern : std/core/types/string;
pub val .tag-ExnSystem : std/core/types/string;
pub val .tag-ExnInternal : std/core/types/string;
// Automatically generated. Retrieves the `message` constructor field of the `:exception` type.
pub fun message : (^ exception : exception) -> std/core/types/string;
// Automatically generated. Retrieves the `info` constructor field of the `:exception` type.
pub fun info : (^ exception : exception) -> exception-info;
pub fun .copy : (.this : exception, message : (std/core/types/optional :: V -> V)<std/core/types/string>, info : (std/core/types/optional :: V -> V)<exception-info>) -> exception;
// Automatically generated. Retrieves the `dref` constructor field of the `:delayed` type.
fun dref : forall<(e :: E),a> (^ delayed : (delayed :: (E, V) -> V)<(e :: E),a>) -> (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>;
pub fun .copy.1 : forall<(e :: E),a> (.this : (delayed :: (E, V) -> V)<(e :: E),a>, dref : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>) -> (delayed :: (E, V) -> V)<(e :: E),a>;
// Automatically generated. Tests for the `Error` constructor of the `:error` type.
pub fun is-error : forall<a> (^ error : (error :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Ok` constructor of the `:error` type.
pub fun is-ok : forall<a> (^ error : (error :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Nil` constructor of the `:list` type.
pub fun is-nil : forall<a> (^ list : (list :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Tests for the `Cons` constructor of the `:list` type.
pub fun is-cons : forall<a> (^ list : (list :: V -> V)<a>) -> std/core/types/bool;
// Automatically generated. Retrieves the `str` constructor field of the `:sslice` type.
fun str : (^ sslice : sslice) -> std/core/types/string;
// Automatically generated. Retrieves the `start` constructor field of the `:sslice` type.
fun start : (^ sslice : sslice) -> std/core/types/ssize_t;
// Automatically generated. Retrieves the `len` constructor field of the `:sslice` type.
fun len : (^ sslice : sslice) -> std/core/types/ssize_t;
pub fun .copy.2 : (.this : sslice, str : (std/core/types/optional :: V -> V)<std/core/types/string>, start : (std/core/types/optional :: V -> V)<std/core/types/ssize_t>, len : (std/core/types/optional :: V -> V)<std/core/types/ssize_t>) -> sslice;
// Automatically generated. Retrieves the `head` constructor field of the `:stream` type.
pub fun head : forall<a> (^ stream : (stream :: V -> V)<a>) -> a;
// Automatically generated. Retrieves the `tail` constructor field of the `:stream` type.
pub fun tail : forall<a> (^ stream : (stream :: V -> V)<a>) -> (stream :: V -> V)<a>;
pub fun .copy.3 : forall<a> (.this : (stream :: V -> V)<a>, head : (std/core/types/optional :: V -> V)<a>, tail : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>) -> (stream :: V -> V)<a>;
// select `throw-exn` operation out of the `:exn` effect handler
pub fun .select-throw-exn : forall<a,(e :: E),b> (^ hnd : (.hnd-exn :: (E, V) -> V)<(e :: E),b>) -> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,a,(.hnd-exn :: (E, V) -> V),(e :: E),b>;
// runtime tag for the `:exn` effect
pub val .tag-exn : (std/core/hnd/htag :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>;
// handler for the `:exn` effect
pub fun .handle-exn : forall<a,(e :: E),b> (cfc : std/core/types/int32, hnd : (.hnd-exn :: (E, V) -> V)<(e :: E),b>, ret : (res : a) -> (e :: E) b, action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) b;
// Internal export for the regex module
pub fun .new-sslice : (str : std/core/types/string, start : std/core/types/ssize_t, len : std/core/types/ssize_t) -> sslice;
// Unsafe: transform any type to a `null` type; used internally by the compiler.
pub fun .null-any : forall<a> (x : a) -> (null :: V -> V)<a>;
pub fun int.8 : (b : std/core/types/bool) -> std/core/types/int;
pub fun int.9 : (x : std/core/types/order) -> std/core/types/int;
val redirect : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/maybe :: V -> V)<(std/core/types/string) -> <(console :: X)> ()>>;
// Print a string to the console, including a final newline character.
fun xprintsln : (s : std/core/types/string) -> <(console :: X)> ();
fun string-compare : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/int;
// Convert an integer to an `:int32`. The number is _clamped_ to the maximal or minimum `:int32`
// value if it is outside the range of an `:int32`.
pub fun int32 : (i : std/core/types/int) -> std/core/types/int32;
// Convert an integer to an `:ssize_t`. The number is _clamped_ to the maximal or minimum `:ssize_t`
// value if it is outside the range of an `:ssize_t`.
pub fun ssize_t : (i : std/core/types/int) -> std/core/types/ssize_t;
// Convert a character to a string
pub fun string : (c : std/core/types/char) -> std/core/types/string;
// Convert a vector of characters to a string.
pub fun string.1 : ((std/core/types/vector :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Convert a list of characters to a string
pub fun string.2 : (cs : (list :: V -> V)<std/core/types/char>) -> (total :: E) std/core/types/string;
// O(n). Copy the `slice` argument into a fresh string.
// Takes O(1) time if the slice covers the entire string.
pub fun string.3 : (slice : sslice) -> std/core/types/string;
// Convert a `:maybe` string to a string using the empty sting for `Nothing`
pub fun string.4 : (ms : (std/core/types/maybe :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Convert a vector to a list with an optional tail.
pub fun vlist : forall<a> (v : (std/core/types/vector :: V -> V)<a>, tail : (std/core/types/optional :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
fun int-show-hex : (i : std/core/types/int, use-capitals : std/core/types/bool) -> std/core/types/string;
fun repeatz : (s : std/core/types/string, n : std/core/types/ssize_t) -> std/core/types/string;
fun show-expx : (d : std/core/types/float64, prec : std/core/types/int32) -> std/core/types/string;
fun show-fixedx : (d : std/core/types/float64, prec : std/core/types/int32) -> std/core/types/string;
// Print a string to the console
fun xprints : (s : std/core/types/string) -> <(console :: X)> ();
// Raise an integer `i` to the power of `exp`.
pub fun pow : (i : std/core/types/int, exp : std/core/types/int) -> std/core/types/int;
// O(`count`). Advance the start position of a string slice by `count` characters
// up to the end of the string.
// A negative `count` advances the start position backwards upto the first position
// in a string.
// Maintains the character count of the original slice upto the end of the string.
// For example:
//
// * `"abc".first.advance(1).string == "b"`,
// * `"abc".first.advance(3).string == ""`,
// * `"abc".last.advance(-1).string == "b"`.
//
pub fun advance : (slice : sslice, ^ count : std/core/types/int) -> sslice;
// Apply a function `f` to a specified argument `x`.
pub fun apply : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, x : a) -> (e :: E) b;
fun unsafe-assert-fail : (msg : std/core/types/string) -> ();
// O(`count`). Extend a string slice by `count` characters up to the end of the string.
// A negative `count` shrinks the slice up to the empty slice.
// For example:
//
// * `"abc".first.extend(1).string == "ab"`
// * `"abc".last.extend(-1).string == ""`
//
pub fun extend : (slice : sslice, ^ count : std/core/types/int) -> sslice;
fun first1 : (s : std/core/types/string) -> sslice;
// Convert a string to upper-case
pub fun to-upper : (s : std/core/types/string) -> std/core/types/string;
pub fun cdiv-exp10 : (i : std/core/types/int, n : std/core/types/int) -> std/core/types/int;
pub fun mul-exp10 : (i : std/core/types/int, n : std/core/types/int) -> std/core/types/int;
// Return the common prefix of two strings (upto `upto` characters (default is minimum length of the two strings))
pub fun common-prefix : (s : std/core/types/string, t : std/core/types/string, ^ upto : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// lifted local: concat, concat-pre
fun .ctail-lift17183-concat : forall<a> (ys : (list :: V -> V)<a>, zss : (list :: V -> V)<(list :: V -> V)<a>>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// lifted local: concat, concat-pre
fun .lift17183-concat : forall<a> (ys : (list :: V -> V)<a>, zss : (list :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Concatenate all lists in a list (e.g. flatten the list). (tail-recursive)
pub fun concat : forall<a> (xss : (list :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// The `const` funs returns its first argument and ignores the second.
pub fun const : forall<a,b> (x : a, y : b) -> a;
// Return a 'constant' function that ignores its argument and always returns the same result
pub fun const.1 : forall<a,b> (default : a) -> (total :: E) ((x : b) -> a);
// If the slice is not empty,
// return the first character, and a new slice that is advanced by 1.
pub fun next : (slice : sslice) -> (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>;
// Return the number of decimal digits of `i`. Return `0` when `i==0`.
pub fun count-digits : (i : std/core/types/int) -> std/core/types/int;
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
pub fun default : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, nothing : a) -> a;
// Use default value `def` in case of an error.
pub fun default.1 : forall<a> (t : (error :: V -> V)<a>, def : a) -> a;
// Transform an `:error` type to an `:either` value.
pub fun either : forall<a> (t : (error :: V -> V)<a>) -> (std/core/types/either :: (V, V) -> V)<exception,a>;
fun xends-with : (s : std/core/types/string, post : std/core/types/string) -> std/core/types/bool;
// monadic lift
fun .mlift17667-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) (list :: V -> V)<b>, zz : (list :: V -> V)<a>, ys1.17210 : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17668-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) (list :: V -> V)<b>, zz : (list :: V -> V)<a>, ys1.17210 : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
fun .ctail-lift17184-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
fun .ctailm-lift17184-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: flatmap, flatmap-pre
fun .lift17184-flatmap : forall<a,b,(e :: E)> (f : (a) -> (e :: E) (list :: V -> V)<b>, ys : (list :: V -> V)<b>, zs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the result lists from applying a function to all elements.
pub fun flatmap : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: reverse-append, reverse-acc
fun .lift17185-reverse-append : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Efficiently reverse a list `xs` and append it to `tl`:
// `reverse-append(xs,tl) == reserve(xs) ++ tl
pub fun reverse-append : forall<a> (xs : (list :: V -> V)<a>, tl : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// monadic lift
fun .mlift17669-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, x0 : a) -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>,(std/core/types/div :: X)|(e :: E)> a;
// monadic lift
fun .mlift17670-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, .y.17346 : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>,(std/core/types/div :: X)|(e :: E)> a) -> <(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/types/div :: X),(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(e :: E)> a;
// monadic lift
fun .mlift17671-force : forall<a,(e :: E)> (r : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>, .y.17344 : (std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/div :: E),(std/core/types/alloc :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(e :: E)> a;
// Force a delayed value; the value is computed only on the first
// call to `force` and cached afterwards.
pub fun force : forall<a,(e :: E)> (delayed : (delayed :: (E, V) -> V)<(e :: E),a>) -> (e :: E) a;
// Generic show: shows the internal representation of an object as a string
// Note: this breaks parametricity so it should not be pub
fun gshow : forall<a> (a) -> std/core/types/string;
// Return the host environment: `dotnet`, `browser`, `webworker`, `node`, or `libc`.
pub fun host : () -> <(std/core/types/ndet :: X)> std/core/types/string;
// clamp an `:int` to fit in an `:int64_t`.
pub fun int64 : (i : std/core/types/int) -> std/core/types/int64;
// The `ignore` function ignores its argument.
pub fun ignore : forall<a> (x : a) -> ();
// clamp an `:int` to fit in an `:int16`.
pub fun int16 : (i : std/core/types/int) -> std/core/types/int16;
// clamp an `:int` to fit in an `:int8`.
pub fun int8 : (i : std/core/types/int) -> std/core/types/int8;
// lifted local: intersperse, before0
fun .ctail-lift17186-intersperse : forall<a> (sep : a, ys : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// lifted local: intersperse, before0
fun .lift17186-intersperse : forall<a> (sep : a, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Insert a separator `sep`  between all elements of a list `xs` .
pub fun intersperse : forall<a> (xs : (list :: V -> V)<a>, sep : a) -> (list :: V -> V)<a>;
// clamp an `:int` to fit in an `:intptr_t`. 
pub fun intptr_t : (i : std/core/types/int) -> std/core/types/intptr_t;
// Is this an even integer?
pub fun is-even : (i : std/core/types/int) -> std/core/types/bool;
// Return the number of ending `0` digits of `i`. Return `0` when `i==0`.
pub fun is-exp10 : (i : std/core/types/int) -> std/core/types/int;
fun last1 : (s : std/core/types/string) -> sslice;
// Used by the compiler to wrap main console applications
pub fun main-console : forall<a,(e :: E)> (main : () -> (e :: E) a) -> (e :: E) a;
// monadic lift
fun .mlift17672-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, yy : (list :: V -> V)<a>, .ctail.17244 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17673-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, yy : (list :: V -> V)<a>, .ctail.17249 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-peek, mappeek
fun .ctail-lift17187-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-peek, mappeek
fun .ctailm-lift17187-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-peek, mappeek
fun .lift17187-map-peek : forall<a,b,(e :: E)> (f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where `f` takes
// both the current element and the tail list as arguments.
pub fun map-peek : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
pub fun mbint : (m : (std/core/types/maybe :: V -> V)<std/core/types/int>) -> std/core/types/int;
pub fun negate : (i : std/core/types/int) -> std/core/types/int;
val trace-enabled : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/bool>;
// Compose two funs `f` and `g`.
pub fun o : forall<a,b,c,(e :: E)> (f : (a) -> (e :: E) b, g : (c) -> (e :: E) a) -> ((x : c) -> (e :: E) b);
// Set a `hndler` that is always called when the `action` finishes (either normally or with an exception).
pub fun on-exit : forall<a,(e :: E)> (hndler : () -> (e :: E) (), action : () -> (e :: E) a) -> (e :: E) a;
// monadic lift
fun .mlift17674-once : forall<(_h :: H),(_e :: E),a> (calc : () -> a, r : (std/core/types/ref :: (H, V) -> V)<(_h :: H),(std/core/types/maybe :: V -> V)<a>>, .y.17363 : (std/core/types/maybe :: V -> V)<a>) -> <(std/core/types/read :: H -> X)<(_h :: H)>,(std/core/types/write :: H -> X)<(_h :: H)>,(std/core/types/div :: E)|(_e :: E)> a;
// Given a total function to calculate a value `:a`, return
// a total function that only calculates the value once and then
// returns the cached result.
pub fun once : forall<a> (calc : () -> a) -> (() -> a);
fun xparse-int : (s : std/core/types/string, hex : std/core/types/bool) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
// Internal: used for value effects
// TODO: revisit value effects codegen
pub fun phantom : forall<a> () -> a;
// Returns a singleton list.
pub fun single : forall<a> (x : a) -> (list :: V -> V)<a>;
// Convert a string to lower-case
pub fun to-lower : (s : std/core/types/string) -> std/core/types/string;
fun xtrace : (message : std/core/types/string) -> ();
fun xtrace-any : forall<a> (message : std/core/types/string, x : a) -> ();
// clamp an `:int` to fit in an `:int8` but interpret the `:int` as an unsigned 8-bit value,
// and clamp between 0 and 255.
pub fun uint8 : (i : std/core/types/int) -> std/core/types/int8;
val unique-count : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),std/core/types/int>;
// _Unsafe_. This function removes the exception effect (`:exn`) from the effect of an action
pub fun unsafe-no-exn : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a;
pub fun unvlist : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<a>;
// Create a new vector of length `n`  with initial elements given by function `f` .
fun vector-initz : forall<a> (n : std/core/types/ssize_t, f : (std/core/types/ssize_t) -> a) -> (std/core/types/vector :: V -> V)<a>;
pub fun (!=.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (!=.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
// Add two integers.
pub fun (+.4) : (x : std/core/types/int, y : std/core/types/int) -> std/core/types/int;
// Add two character code points
pub fun (+.3) : (c : std/core/types/char, d : std/core/types/char) -> (total :: E) std/core/types/char;
// Append two lists.
pub fun .ctail-append : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Append two lists.
pub fun append : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Append two lists.
pub fun (++) : forall<a> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Append two strings.
pub fun (++.1) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/string;
// Substract two integers.
pub fun (-.4) : (x : std/core/types/int, y : std/core/types/int) -> std/core/types/int;
// Substract two character codePoints
pub fun (-.3) : (c : std/core/types/char, d : std/core/types/char) -> (total :: E) std/core/types/char;
fun printsln : (s : std/core/types/string) -> <(console :: X)> ();
pub fun (==.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (==.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
pub fun (<.5) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (<.6) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
pub fun order : (i : std/core/types/int) -> std/core/types/order;
// Compare two strings.
// Uses the character codes directly for comparison
pub fun compare.3 : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/order;
pub fun (<.7) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
pub fun (>.3) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (>.4) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
pub fun (>.5) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
pub fun compare.1 : (x : std/core/types/char, y : std/core/types/char) -> std/core/types/order;
pub fun compare.2 : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/order;
pub fun (>=.4) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (>=.5) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
pub fun (>=.6) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
// lifted local: joinsep, join-acc
fun .lift17188-joinsep : (sep : std/core/types/string, ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
fun joinsep : (xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
// lifted local: join.2, join-acc
fun .lift17189-join.2 : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list
pub fun join.2 : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// Concatenate all strings in a list using a specific separator
pub fun join.3 : (xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string;
pub fun (<=.5) : (x : std/core/types/order, y : std/core/types/order) -> std/core/types/bool;
pub fun (<=.6) : (x : std/core/types/bool, y : std/core/types/bool) -> std/core/types/bool;
pub fun (<=.7) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/bool;
pub fun inc : (i : std/core/types/int) -> std/core/types/int;
fun decr : (i : std/core/types/int32) -> std/core/types/int32;
fun decr.1 : (i : std/core/types/ssize_t) -> std/core/types/ssize_t;
fun incr : (i : std/core/types/int32) -> std/core/types/int32;
fun incr.1 : (i : std/core/types/ssize_t) -> std/core/types/ssize_t;
// monadic lift
fun .mlift17675-op : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), end : std/core/types/ssize_t, i : std/core/types/ssize_t, wild_ : ()) -> (e :: E) ();
// lifted local: forz, rep
fun .lift17190-forz : forall<(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (), end : std/core/types/ssize_t, i : std/core/types/ssize_t) -> (e :: E) ();
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
fun forz : forall<(e :: E)> (start : std/core/types/ssize_t, end : std/core/types/ssize_t, action : (std/core/types/ssize_t) -> (e :: E) ()) -> (e :: E) ();
fun foreach-indexedz : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (std/core/types/ssize_t, a) -> (e :: E) ()) -> (e :: E) ();
// lifted local: length.1, len0
fun .lift17191-length.1 : forall<a> (ys : (list :: V -> V)<a>, acc : std/core/types/int) -> std/core/types/int;
// Returns the length of a list.
pub fun length.1 : forall<a> (xs : (list :: V -> V)<a>) -> std/core/types/int;
// Return the length of a vector.
pub fun length.2 : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/int;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub fun .ctail-list : (lo : std/core/types/int, hi : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<std/core/types/int>>) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub fun list : (lo : std/core/types/int, hi : std/core/types/int) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub fun .ctail-list.1 : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<std/core/types/int>>) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub fun list.1 : (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int) -> (total :: E) (list :: V -> V)<std/core/types/int>;
// monadic lift
fun .mlift17676-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, .ctail.17256 : a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17677-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, .ctail.17261 : a) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub fun .ctail-list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub fun .ctailm-list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Applies a function `f` to list of increasing elements from `lo`  to `hi`
// (including both `lo`  and `hi` ).
// If `lo > hi`  the function returns the empty list.
pub fun list.2 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17678-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, .ctail.17262 : a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17679-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, f : (std/core/types/int) -> (e :: E) a, hi : std/core/types/int, lo : std/core/types/int, stride : std/core/types/int, .ctail.17267 : a) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub fun .ctail-list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub fun .ctailm-list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Returns an integer list of increasing elements from `lo`  to `hi` with stride `stride`.
// If `lo > hi`  the function returns the empty list.
pub fun list.3 : forall<a,(e :: E)> (lo : std/core/types/int, hi : std/core/types/int, stride : std/core/types/int, f : (std/core/types/int) -> (e :: E) a) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17680-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) b, xx : (list :: V -> V)<a>, .ctail.17268 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17681-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) b, xx : (list :: V -> V)<a>, .ctail.17273 : b) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
pub fun .ctail-map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
pub fun .ctailm-map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence.
pub fun map.5 : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// Create a list of characters from `lo`  to `hi`  (inclusive).
pub fun list.4 : (lo : std/core/types/char, hi : std/core/types/char) -> (total :: E) (list :: V -> V)<std/core/types/char>;
// Convert a `:maybe` type to a list type.
pub fun list.5 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> (list :: V -> V)<a>;
// Convert a string to a list of characters
pub fun list.6 : (s : std/core/types/string) -> (total :: E) (list :: V -> V)<std/core/types/char>;
// Convert a vector to a list.
pub fun list.7 : forall<a> (v : (std/core/types/vector :: V -> V)<a>) -> (list :: V -> V)<a>;
// monadic lift
fun .mlift17682-map : forall<a,(e :: E)> (.y.17398 : a) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
pub fun map : forall<a,b,(e :: E)> (m : (std/core/types/maybe :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
fun .mlift17683-map.1 : forall<a,b,(e :: E)> (.y.17400 : b) -> (e :: E) (std/core/types/either :: (V, V) -> V)<a,b>;
// Map over the `Right` component of an `:either` type.
pub fun map.1 : forall<a,b,c,(e :: E)> (e : (std/core/types/either :: (V, V) -> V)<a,b>, f : (b) -> (e :: E) c) -> (e :: E) (std/core/types/either :: (V, V) -> V)<a,c>;
// monadic lift
fun .mlift17684-map.2 : forall<a,(e :: E)> (.y.17402 : a, .y.17403 : a) -> (e :: E) (a, a);
// monadic lift
fun .mlift17685-map.2 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a), .y.17402 : b) -> (e :: E) (b, b);
pub fun map.2 : forall<a,b,(e :: E)> (t : (a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b);
// monadic lift
fun .mlift17686-map.3 : forall<a,(e :: E)> (.y.17404 : a, .y.17405 : a, .y.17406 : a) -> (e :: E) (a, a, a);
// monadic lift
fun .mlift17687-map.3 : forall<a,b,(e :: E)> (.y.17404 : b, f : (a) -> (e :: E) b, t : (a, a, a), .y.17405 : b) -> (e :: E) (b, b, b);
// monadic lift
fun .mlift17688-map.3 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a, a), .y.17404 : b) -> (e :: E) (b, b, b);
pub fun map.3 : forall<a,b,(e :: E)> (t : (a, a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b, b);
// monadic lift
fun .mlift17689-map.4 : forall<a,(e :: E)> (.y.17407 : a, .y.17408 : a, .y.17409 : a, .y.17410 : a) -> (e :: E) (a, a, a, a);
// monadic lift
fun .mlift17690-map.4 : forall<a,b,(e :: E)> (.y.17407 : b, .y.17408 : b, f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17409 : b) -> (e :: E) (b, b, b, b);
// monadic lift
fun .mlift17691-map.4 : forall<a,b,(e :: E)> (.y.17407 : b, f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17408 : b) -> (e :: E) (b, b, b, b);
// monadic lift
fun .mlift17692-map.4 : forall<a,b,(e :: E)> (f : (a) -> (e :: E) b, t : (a, a, a, a), .y.17407 : b) -> (e :: E) (b, b, b, b);
pub fun map.4 : forall<a,b,(e :: E)> (t : (a, a, a, a), f : (a) -> (e :: E) b) -> (e :: E) (b, b, b, b);
// Apply a function `f` to each character in a string
pub fun map.6 : forall<(e :: E)> (s : std/core/types/string, f : (std/core/types/char) -> (e :: E) std/core/types/char) -> (e :: E) std/core/types/string;
// monadic lift
fun .mlift17693-map.7 : forall<a,(e :: E)> (i : std/core/types/ssize_t, w : (std/core/types/vector :: V -> V)<a>, .y.17412 : a) -> (e :: E) ();
// monadic lift
fun .mlift17694-map.7 : forall<a,(e :: E)> (w : (std/core/types/vector :: V -> V)<a>, wild_ : ()) -> (e :: E) (std/core/types/vector :: V -> V)<a>;
// Apply a total function `f` to each element in a vector `v`
pub fun map.7 : forall<a,b,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) b) -> (e :: E) (std/core/types/vector :: V -> V)<b>;
// Right-align a string to width `width`  using `fill`  (default is a space) to fill from the left.
pub fun pad-left : (s : std/core/types/string, ^ width : std/core/types/int, fill : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Show an `:int` as a hexadecimal value.\
// The `width`  parameter specifies how wide the hex value is where `"0"`  is used to align.\
// The `use-capitals` parameter (= `True`) determines if captical letters should be used to display the hexadecimal digits.\
// The `pre` (=`"0x"`) is an optional prefix for the number (goes between the sign and the number).
pub fun show-hex : (i : std/core/types/int, width : (std/core/types/optional :: V -> V)<std/core/types/int>, use-capitals : (std/core/types/optional :: V -> V)<std/core/types/bool>, pre : (std/core/types/optional :: V -> V)<std/core/types/string>) -> std/core/types/string;
pub fun sign.1 : (d : std/core/types/float64) -> std/core/types/order;
// Is the integer positive (stricly greater than zero)
pub fun is-pos.2 : (i : std/core/types/int) -> std/core/types/bool;
// Is the value positive?
pub fun is-pos.3 : (d : std/core/types/float64) -> std/core/types/bool;
// Is the list empty?
pub fun is-empty : forall<a> (xs : (list :: V -> V)<a>) -> std/core/types/bool;
// Is a slice empty?
pub fun is-empty.1 : (slice : sslice) -> std/core/types/bool;
// Is a string empty?
pub fun is-empty.2 : (s : std/core/types/string) -> std/core/types/bool;
pub fun (||) : forall<a> (m1 : (std/core/types/maybe :: V -> V)<a>, m2 : (std/core/types/maybe :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Choose a non-empty string
pub fun (||.1) : (x : std/core/types/string, y : std/core/types/string) -> std/core/types/string;
// Show a character as a string
fun show-char : (c : std/core/types/char) -> std/core/types/string;
// Show a `:float64` in exponential (scientific) notation.
// The optional `precision` (= `-17`) specifies the precision.
// If `>=0` it specifies the number of digits behind the dot (up to `17` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
pub fun show-exp : (d : std/core/types/float64, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show a `:float64` fixed-point notation.
// The optional `precision` (= `-2`) specifies the maximum precision.
// If `>=0` it specifies the number of digits behind the dot (up to `20` max).
// If negative, then at most the absolute value of `precision` digits behind the dot are used.
// This may still show a number in exponential notation if the it is too small or large,
// in particular, for  a `d` where `d > 1.0e21` or `d < 1.0e-15`, or if
// `precision.abs > 17`, the `show-exp` routine is used.
pub fun show-fixed : (d : std/core/types/float64, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// lifted local: show-list, join-acc
fun .lift17192-show-list : (sep : std/core/types/string, ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// monadic lift
fun .mlift17695-show-list : forall<(e :: E)> (.y.17414 : (list :: V -> V)<std/core/types/string>) -> (e :: E) std/core/types/string;
// Convert a list to a string
pub fun show-list : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, show-elem : (a) -> (e :: E) std/core/types/string) -> (e :: E) std/core/types/string;
// Convert an `:int` to a string
pub fun show : (i : std/core/types/int) -> std/core/types/string;
// Show a `:float64` as a string.
// If `d >= 1.0e-5` and `d < 1.0e+21`, `show-fixed` is used and otherwise `show-exp`.
// Default `precision` is `-17`.
pub fun show.1 : (d : std/core/types/float64, precision : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/string;
// Show the exception message
pub fun show.10 : (exn : exception) -> std/core/types/string;
// Show a `:char` as a character literal
pub fun show.2 : (c : std/core/types/char) -> std/core/types/string;
// lifted local: show.3, join-acc
fun .lift17193-show.3 : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Show a string as a string literal
pub fun show.3 : (s : std/core/types/string) -> std/core/types/string;
// Convert a `:bool` to a string
pub fun show.4 : (b : std/core/types/bool) -> std/core/types/string;
// Convert a unit value `()` to a string
pub fun show.5 : (u : ()) -> std/core/types/string;
// Show an `:sslice` as a string literal
pub fun show.6 : (s : sslice) -> std/core/types/string;
pub fun show.7 : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
pub fun show.8 : (xs : (list :: V -> V)<std/core/types/int>) -> std/core/types/string;
pub fun show.9 : (xs : (list :: V -> V)<std/core/types/bool>) -> std/core/types/string;
// Print a string to the console, including a final newline character.
pub fun println : (s : std/core/types/string) -> <(console :: X)> ();
// Print an integer to the console, including a final newline character.
pub fun println.1 : (i : std/core/types/int) -> <(console :: X)> ();
// Print a float64 to the console, including a final newline character.
pub fun println.2 : (d : std/core/types/float64) -> <(console :: X)> ();
// Print a boolean to the console, including a final newline character
pub fun println.3 : (b : std/core/types/bool) -> <(console :: X)> ();
// Print a character to the console, including a final newline character.
pub fun println.4 : (c : std/core/types/char) -> <(console :: X)> ();
// Print a unit value to the console, including a final newline character
pub fun println.5 : (u : ()) -> <(console :: X)> ();
fun prints : (s : std/core/types/string) -> <(console :: X)> ();
// call `throw-exn` operation of the `:exn` effect
pub fun throw-exn : forall<a> (exn : exception) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
pub fun .default-exn : forall<(e :: E)> (action : () -> <(console :: X),(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> ()) -> <(console :: X)|(e :: E)> ();
// Get (zero-based) element `n`  of a list. Return a `:maybe` type.
pub fun ([].2) : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// Raise an integer `i` to the power of `exp`.
pub fun (^.1) : (i : std/core/types/int, exp : std/core/types/int) -> std/core/types/int;
// O(1). Return the string slice from the end of `slice` argument
// to the end of the string.
pub fun after : (slice : sslice) -> sslice;
// monadic lift
fun .mlift17696-all : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (list :: V -> V)<a>, .y.17417 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Do all elements satisfy a predicate ?
pub fun all : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
// monadic lift
fun .mlift17697-any : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xx : (list :: V -> V)<a>, .y.17421 : std/core/types/bool) -> (e :: E) std/core/types/bool;
// Are there any elements in a list that satisfy a predicate ?
pub fun any : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) std/core/types/bool;
pub fun assert : (message : std/core/types/string, condition : std/core/types/bool) -> ();
// Return the element at position `index` in vector `v`, or `Nothing` if out of bounds
pub fun at : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, ^ index : std/core/types/int) -> (std/core/types/maybe :: V -> V)<a>;
// O(1). Return the string slice from the start of a string up to the
// start of `slice` argument.
pub fun before : (slice : sslice) -> sslice;
// Convert an int to a boolean, using `False` for 0 and `True` otherwise.
pub fun bool : (i : std/core/types/int) -> std/core/types/bool;
// Convert a `:maybe` type to a boolean using `False` for `Nothing` and `True` for `Just`.
pub fun bool.1 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> std/core/types/bool;
// Convert a string to a boolean, using `False` for the empty string and `True` otherwise.
pub fun bool.2 : (s : std/core/types/string) -> std/core/types/bool;
// O(`n`). The first `n` (default = `1`) characters in a string.
pub fun first : (s : std/core/types/string, n : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// Convert the first character of a string to uppercase.
pub fun capitalize : (s : std/core/types/string) -> std/core/types/string;
// Catch any exception raised in `action` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
pub fun try : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl : (exception) -> (e :: E) a) -> (e :: E) a;
// monadic lift
fun .mlift17698-try.1 : forall<a,(e :: E)> (.y.17426 : a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> (error :: V -> V)<a>;
// Transform an exception effect to an  `:error` type.
pub fun try.1 : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) (error :: V -> V)<a>;
// _Deprecated_; use `try` instead. Catch an exception raised by `throw` and handle it.
// Use `on-exn` or `on-exit` when appropiate.
pub fun catch : forall<a,(e :: E)> (action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl : (exception) -> (e :: E) a) -> (e :: E) a;
pub fun cdivmod-exp10 : (i : std/core/types/int, n : std/core/types/int) -> (std/core/types/int, std/core/types/int);
// Concatenate a list of `:maybe` values
pub fun .ctail-concat-maybe : forall<a> (xs : (list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Concatenate a list of `:maybe` values
pub fun concat-maybe : forall<a> (xs : (list :: V -> V)<(std/core/types/maybe :: V -> V)<a>>) -> (list :: V -> V)<a>;
// monadic lift
fun .mlift17699-op : forall<a,(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/ssize_t, i : std/core/types/ssize_t, .y.17429 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted local: for-whilez, rep
fun .lift17194-for-whilez : forall<a,(e :: E)> (action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/ssize_t, i : std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
fun for-whilez : forall<a,(e :: E)> (start : std/core/types/ssize_t, end : std/core/types/ssize_t, action : (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// O(1). The entire string as a slice
pub fun slice : (s : std/core/types/string) -> sslice;
// monadic lift
fun .mlift17700-foreach-while : forall<a,b,(e :: E)> (action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17434 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// Invoke `action` for each element of a list while `action` return `Nothing`
pub fun foreach-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
fun .mlift17701-foreach-while.1 : forall<a,(e :: E)> (action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, rest : sslice, .y.17438 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Apply a function for each character in a string slice.
// If `action` returns `Just`, the function returns immediately with that result.
pub fun foreach-while.1 : forall<a,(e :: E)> (slice : sslice, action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Invoke a function for each character in a string.
// If `action` returns `Just`, the function returns immediately with that result.
pub fun foreach-while.2 : forall<a,(e :: E)> (s : std/core/types/string, action : (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Invoke a function `f` for each element in a vector `v`.
// If `f` returns `Just`, the iteration is stopped early and the result is returned.
pub fun foreach-while.3 : forall<a,b,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (std/core/types/maybe :: V -> V)<b>;
// monadic lift
fun .mlift17702-foreach : forall<a,(e :: E)> (action : (a) -> (e :: E) (), xx : (list :: V -> V)<a>, wild_ : ()) -> (e :: E) ();
// Invoke `action` for each element of a list
pub fun foreach : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
fun .mlift17703-foreach.1 : forall<_a,(e :: E)> (wild_ : ()) -> (e :: E) (std/core/types/maybe :: V -> V)<_a>;
// monadic lift
fun .mlift17704-foreach.1 : forall<_a,(e :: E)> (wild_0 : (std/core/types/maybe :: V -> V)<_a>) -> (e :: E) ();
// Apply a function for each character in a string slice.
pub fun foreach.1 : forall<(e :: E)> (slice : sslice, action : (c : std/core/types/char) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
fun .mlift17705-foreach.2 : forall<_a,(e :: E)> (wild_ : ()) -> (e :: E) (std/core/types/maybe :: V -> V)<_a>;
// monadic lift
fun .mlift17706-foreach.2 : forall<_a,(e :: E)> (wild_0 : (std/core/types/maybe :: V -> V)<_a>) -> (e :: E) ();
// Invoke a function for each character in a string
pub fun foreach.2 : forall<(e :: E)> (s : std/core/types/string, action : (c : std/core/types/char) -> (e :: E) ()) -> (e :: E) ();
// Invoke a function `f` for each element in a vector `v`
pub fun foreach.3 : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (a) -> (e :: E) ()) -> (e :: E) ();
// O(n). Return the number of characters in a string.
pub fun count.1 : (s : std/core/types/string) -> std/core/types/int;
// O(n). Return the number of characters in a string slice
pub fun count.2 : (slice : sslice) -> std/core/types/int;
// Count the number of times a predicate is true for each character in a string
pub fun count.3 : (s : std/core/types/string, pred : (std/core/types/char) -> std/core/types/bool) -> std/core/types/int;
pub fun dec : (i : std/core/types/int) -> std/core/types/int;
// Create a new `:delayed` value.
pub fun delay : forall<a,(e :: E)> (action : () -> (e :: E) a) -> (delayed :: (E, V) -> V)<(e :: E),a>;
// Calculate `10^exp`
pub fun exp10 : (exp : std/core/types/int) -> std/core/types/int;
// Is the integer negative (stricly smaller than zero)
pub fun is-neg.2 : (i : std/core/types/int) -> std/core/types/bool;
// Is the value negative?
pub fun is-neg.3 : (d : std/core/types/float64) -> std/core/types/bool;
pub fun divmod-exp10 : (i : std/core/types/int, n : std/core/types/int) -> (std/core/types/int, std/core/types/int);
// Drop the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub fun drop : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (list :: V -> V)<a>;
// monadic lift
fun .mlift17707-drop-while : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, xs : (list :: V -> V)<a>, xx : (list :: V -> V)<a>, .y.17454 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Drop all initial elements that satisfy `predicate`
pub fun drop-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// An empty slice
val empty : sslice;
// Does string `s`  end with `post`?
// If so, returns a slice of `s` from the start up to the `post` string at the end.
pub fun ends-with : (s : std/core/types/string, post : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Throw an exception with a specified message.
pub fun throw : forall<a> (message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// monadic lift
fun .mlift17708-error-pattern : forall<a> (definition : std/core/types/string, location : std/core/types/string, .c.17459 : std/core/types/string) -> a;
// Raise a pattern match exception. This is function is used internally by the
// compiler to generate error messages on pattern match failures.
pub fun error-pattern : forall<a> (location : std/core/types/string, definition : std/core/types/string) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Transform an `:error` type back to an `exn` effect.
pub fun untry : forall<a> (err : (error :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Transform an `:error` type back to an `exn` effect.
pub fun exn : forall<a> (err : (error :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// Calculate `2^exp`.
pub fun exp2 : (exp : std/core/types/int) -> std/core/types/int;
// monadic lift
fun .mlift17709-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17464 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17710-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17469 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
pub fun .ctail-filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
pub fun .ctailm-filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filter([1,2,3],odd?) == [1,3]`
pub fun filter : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17711-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17477 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17712-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17482 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
pub fun .ctail-filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
pub fun .ctailm-filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Retain only those elements of a list that satisfy the given predicate `pred`.
// For example: `filterMap([1,2,3],fn(i) { if i.odd? then Nothing else Just(i*i) }) == [4]`
pub fun filter-map : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
fun is-zero.1 : (i : std/core/types/ssize_t) -> std/core/types/bool;
// Is the value zero?
pub fun is-zero.2 : (d : std/core/types/float64) -> std/core/types/bool;
// Find the first element satisfying some predicate
pub fun find : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<a>;
// O(n). If it occurs, return the position of substring `sub` in `s`, tupled with
// the position just following the substring `sub`.
pub fun find.1 : (s : std/core/types/string, sub : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Return the last index of substring `sub` in `s` if it occurs.
pub fun find-last : (s : std/core/types/string, sub : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Find the first element satisfying some predicate and return it.
pub fun find-maybe : forall<a,b> (xs : (list :: V -> V)<a>, pred : (a) -> (std/core/types/maybe :: V -> V)<b>) -> (std/core/types/maybe :: V -> V)<b>;
// monadic lift
fun .mlift17713-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17490 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17714-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17495 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
pub fun .ctail-flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
pub fun .ctailm-flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Concatenate the `Just` result elements from applying a function to all elements.
pub fun flatmap-maybe : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17715-fold-int : forall<a,(e :: E)> (end : std/core/types/int, f : (std/core/types/int, a) -> (e :: E) a, start0 : std/core/types/int, x : a) -> (e :: E) a;
// fold over the integers between [`start`,`end`] (inclusive).
pub fun fold-int : forall<a,(e :: E)> (start : std/core/types/int, end : std/core/types/int, init : a, f : (std/core/types/int, a) -> (e :: E) a) -> (e :: E) a;
// fold over the integers between [0,`upto`)  (not including `upto`).
pub fun fold-int.1 : forall<a,(e :: E)> (upto : std/core/types/int, init : a, f : (std/core/types/int, a) -> (e :: E) a) -> (e :: E) a;
// monadic lift
fun .mlift17716-foldl : forall<a,(e :: E),b> (f : (a, b) -> (e :: E) a, xx : (list :: V -> V)<b>, .y.17507 : a) -> (e :: E) a;
// Fold a list from the left, i.e. `foldl([1,2],0,(+)) == (0+1)+2`
// Since `foldl` is tail recursive, it is preferred over `foldr` when using an associative function `f`
pub fun foldl : forall<a,b,(e :: E)> ((list :: V -> V)<a>, b, (b, a) -> (e :: E) b) -> (e :: E) b;
pub fun foldl1 : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a;
// lifted local: reverse, reverse-acc
fun .lift17195-reverse : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Reverse a list.
pub fun reverse : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Fold a list from the right, i.e. `foldr([1,2],0,(+)) == 1+(2+0)`
// Note, `foldr` is less efficient than `foldl` as it reverses the list first.
pub fun foldr : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, z : b, f : (a, b) -> (e :: E) b) -> (e :: E) b;
pub fun foldr1 : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, f : (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a;
// monadic lift
fun .mlift17717-op : forall<(e :: E)> (action : (std/core/types/int) -> (e :: E) (), end : std/core/types/int, i : std/core/types/int, wild_ : ()) -> (e :: E) ();
// lifted local: for, rep
fun .lift17196-for : forall<(e :: E)> (action : (std/core/types/int) -> (e :: E) (), end : std/core/types/int, i : std/core/types/int) -> (e :: E) ();
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
pub fun for : forall<(e :: E)> (^ start : std/core/types/int, end : std/core/types/int, action : (std/core/types/int) -> (e :: E) ()) -> (e :: E) ();
// monadic lift
fun .mlift17718-op : forall<a,(e :: E)> (action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int, i : std/core/types/int, .y.17522 : (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// lifted local: for-while, rep
fun .lift17197-for-while : forall<a,(e :: E)> (action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end : std/core/types/int, i : std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// Executes `action`  for each integer between `start`  upto `end`  (including both `start`  and `end` ).
// If `start > end`  the function returns without any call to `action` .
// If `action` returns `Just`, the iteration is stopped and the result returned
pub fun for-while : forall<a,(e :: E)> (start : std/core/types/int, end : std/core/types/int, action : (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>) -> (e :: E) (std/core/types/maybe :: V -> V)<a>;
// monadic lift
fun .mlift17719-foreach-indexed : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, .y.17530 : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
fun .mlift17720-foreach-indexed : forall<(h :: H),(e :: E)> (i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, wild_ : ()) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// monadic lift
fun .mlift17721-foreach-indexed : forall<(h :: H),a,(e :: E)> (action : (std/core/types/int, a) -> (e :: E) (), i : (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>, x : a, j : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ();
// Invoke `action` for each element of a list, passing also the position of the element.
pub fun foreach-indexed : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, action : (std/core/types/int, a) -> (e :: E) ()) -> (e :: E) ();
// Invoke a function `f` for each element in a vector `v`
pub fun foreach-indexed.1 : forall<a,(e :: E)> (v : (std/core/types/vector :: V -> V)<a>, f : (std/core/types/int, a) -> (e :: E) ()) -> (e :: E) ();
// Print a string to the console.
pub fun print : (s : std/core/types/string) -> <(console :: X)> ();
// Print an integer to the console.
pub fun print.1 : (i : std/core/types/int) -> <(console :: X)> ();
// Print a float64 to the console.
pub fun print.2 : (d : std/core/types/float64) -> <(console :: X)> ();
// Print a boolean to the console
pub fun print.3 : (b : std/core/types/bool) -> <(console :: X)> ();
// Print a character to the console.
pub fun print.4 : (c : std/core/types/char) -> <(console :: X)> ();
// Print a unit value to the console
pub fun print.5 : (u : ()) -> <(console :: X)> ();
// Generic print routine: prints the internal representation as a string to the console,
// including a final newline character.
// Note: this breaks parametricity so it should not be pub
fun gprint : forall<a> (x : a) -> <(console :: X)> ();
// Generic print routine: prints the internal representation as a string to the console, including a final newline character.
// Note: this breaks parametricity so it should not be pub
fun gprintln : forall<a> (x : a) -> <(console :: X)> ();
// Return the head of list if the list is not empty.
pub fun head.1 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the head of list if the list is not empty, or use `default` otherwise
pub fun head.2 : forall<a> (xs : (list :: V -> V)<a>, default : a) -> a;
// Return the first character of a string as a string (or the empty string)
pub fun head.3 : (s : std/core/types/string) -> std/core/types/string;
// Return the first character of a string (or `Nothing` for the empty string).
pub fun head-char : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<std/core/types/char>;
// Convenient shorthand to `int32`, e.g. `1234.i32`
pub fun i32 : (i : std/core/types/int) -> std/core/types/int32;
// Convenient shorthand to `int64`, e.g. `1234.i64`
pub fun i64 : (i : std/core/types/int) -> std/core/types/int64;
fun index-of-acc : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool, idx : std/core/types/int) -> std/core/types/int;
// Returns the index of the first element where `pred` holds, or `-1` if no such element exists.
pub fun index-of : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> std/core/types/int;
// Return the list without its last element.
// Return an empty list for an empty list.
pub fun .ctail-init : forall<a> (xs : (list :: V -> V)<a>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Return the list without its last element.
// Return an empty list for an empty list.
pub fun init : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// An invalid slice
val invalid : sslice;
// Is the character a lower-case ASCII character ?
pub fun is-lower : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an upper-case ASCII character ?
pub fun is-upper : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII letter is-
pub fun is-alpha : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII digit ?
pub fun is-digit : (c : std/core/types/char) -> std/core/types/bool;
// Is the character ASCII letter or digit?
pub fun is-alpha-num : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII character, e.g. `c <= '\x7F'`  ?
pub fun is-ascii : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII control character, e.g. `c < ' '`  ?
pub fun is-control : (c : std/core/types/char) -> std/core/types/bool;
// Is the character an ASCII hexa-decimal digit ?
pub fun is-hex-digit : (c : std/core/types/char) -> std/core/types/bool;
// Is a slice not empty?
pub fun is-notempty : (slice : sslice) -> std/core/types/bool;
// Is a string not empty?
pub fun is-notempty.1 : (s : std/core/types/string) -> std/core/types/bool;
// Is a slice invalid?
pub fun is-valid : (slice : sslice) -> std/core/types/bool;
// Tests if a character is an element of `" \t\n\r"`
pub fun is-white : (c : std/core/types/char) -> std/core/types/bool;
// Append `end` to each string in the list `xs` and join them all together.\
// `join-end([],end) === ""`\
// `join-end(["a","b"],"/") === "a/b/"`
pub fun join-end : (xs : (list :: V -> V)<std/core/types/string>, end : std/core/types/string) -> std/core/types/string;
// Return the last element of a list (or `Nothing` for the empty list)
pub fun last : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the last element of a list (or `default` for the empty list)
pub fun last.1 : forall<a> (xs : (list :: V -> V)<a>, default : a) -> a;
// O(`n`). The last `n` (default = `1`) characters in a string
pub fun last.2 : (s : std/core/types/string, n : (std/core/types/optional :: V -> V)<std/core/types/int>) -> sslice;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub fun .ctail-take : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Take the first `n` elements of a list (or fewer if the list is shorter than `n`)
pub fun take : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> (list :: V -> V)<a>;
// split a list at position `n`
pub fun split : forall<a> (xs : (list :: V -> V)<a>, n : std/core/types/int) -> ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Split a string into parts that were delimited by `sep`. The delimeters are not included in the results.
// For example: `split("1,,2",",") == ["1","","2]`
pub fun split.1 : (s : std/core/types/string, sep : std/core/types/string) -> (list :: V -> V)<std/core/types/string>;
// Split a string into at most `n` parts that were delimited by a string `sep`. The delimeters are not included in the results (except for possibly the final part).
// For example: `split("1,2,3",",",2) == ["1","2,3"]`
pub fun split.2 : (s : std/core/types/string, sep : std/core/types/string, ^ n : std/core/types/int) -> (list :: V -> V)<std/core/types/string>;
// Split a string into a list of lines
pub fun lines : (s : std/core/types/string) -> (list :: V -> V)<std/core/types/string>;
// Lookup the first element satisfying some predicate
pub fun lookup : forall<a,b> (xs : (list :: V -> V)<(a, b)>, pred : (a) -> std/core/types/bool) -> (std/core/types/maybe :: V -> V)<b>;
// monadic lift
fun .mlift17722-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a) -> (e :: E) b, i0.17228 : std/core/types/int, yy : (list :: V -> V)<a>, .ctail.17292 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17723-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (idx : std/core/types/int, value : a) -> (e :: E) b, i0.17228 : std/core/types/int, yy : (list :: V -> V)<a>, .ctail.17297 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
fun .ctail-lift17198-map-indexed : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
fun .ctailm-lift17198-map-indexed : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed, map-idx
fun .lift17198-map-indexed : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element and the element itself as arguments.
pub fun map-indexed : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (idx : std/core/types/int, value : a) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17724-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, i0.17230 : std/core/types/int, yy : (list :: V -> V)<a>, .ctail.17298 : b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17725-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, i0.17230 : std/core/types/int, yy : (list :: V -> V)<a>, .ctail.17303 : b) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
fun .ctail-lift17199-map-indexed-peek : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
fun .ctailm-lift17199-map-indexed-peek : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// lifted local: map-indexed-peek, mapidx
fun .lift17199-map-indexed-peek : forall<a,b,(e :: E)> (f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys : (list :: V -> V)<a>, i : std/core/types/int) -> (e :: E) (list :: V -> V)<b>;
// Apply a function `f`  to each element of the input list in sequence where takes
// both the index of the current element, the element itself, and the tail list as arguments.
pub fun map-indexed-peek : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, f : (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17726-op : forall<a,b,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17557 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// monadic lift
fun .mlift17727-op : forall<a,b,(e :: E)> (.accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, xx : (list :: V -> V)<a>, .y.17561 : (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
pub fun .ctail-map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<b>>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
pub fun .ctailm-map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>, .accm : ((list :: V -> V)<b>) -> (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Invoke `action` on each element of a list while `action` returns `Just`
pub fun map-while : forall<a,b,(e :: E)> (xs : (list :: V -> V)<a>, action : (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>) -> (e :: E) (list :: V -> V)<b>;
// Return the maximum of two integers
pub fun max : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int;
// Returns the largest of two floats
pub fun max.1 : (x : std/core/types/float64, y : std/core/types/float64) -> std/core/types/float64;
// Returns the largest element of a list of integers (or `default` (=`0`) for the empty list)
pub fun maximum : (xs : (list :: V -> V)<std/core/types/int>, default : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Returns the largest element of a list of floats (or `0` for the empty list)
pub fun maximum.1 : (xs : (list :: V -> V)<std/core/types/float64>) -> std/core/types/float64;
// Match a `:maybe` value and either return a default value on `Nothing` or apply a function to the value on `Just`
pub fun maybe : forall<a,b,(e :: E)> (m : (std/core/types/maybe :: V -> V)<a>, onNothing : b, onJust : (a) -> (e :: E) b) -> (e :: E) b;
// Convert a `:maybe<a>` value to `:a`, using the `nothing` parameter for `Nothing`.
// This is an alias for `default`.
pub fun maybe.1 : forall<a> (m : (std/core/types/maybe :: V -> V)<a>, nothing : a) -> a;
// Convert a `:either` to a `:maybe` type discarding the value of the `Left` constructor
// and using `Just` for the `Right` constructor.
pub fun maybe.2 : forall<a,b> (e : (std/core/types/either :: (V, V) -> V)<a,b>) -> (std/core/types/maybe :: V -> V)<b>;
// Convert a list to a `:maybe` type, using `Nothing` for an empty list, and otherwise `Just` on the head element.
// Note: this is just `head`.
pub fun maybe.3 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Transform a boolean to a maybe type, using `Nothing` for `False`
pub fun maybe.4 : (b : std/core/types/bool) -> (std/core/types/maybe :: V -> V)<()>;
// Transform an integer to a maybe type, using `Nothing` for `0`
pub fun maybe.5 : (i : std/core/types/int) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
// Transform a string to a maybe type, using `Nothing` for an empty string
pub fun maybe.6 : (s : std/core/types/string) -> (std/core/types/maybe :: V -> V)<std/core/types/string>;
// Transform an `:error` type to a `:maybe` value.
pub fun maybe.7 : forall<a> (t : (error :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Transform a `:null` type to a `:maybe` type. Note that it is not
// always the case that `id(x) == maybe(null(x))` (e.g. when `x = Just(Nothing)`).
pub fun maybe.8 : forall<a> (n : (null :: V -> V)<a>) -> (std/core/types/maybe :: V -> V)<a>;
// Return the minimum of two integers
pub fun min : (i : std/core/types/int, j : std/core/types/int) -> std/core/types/int;
// Returns the smallest of two floats
pub fun min.1 : (x : std/core/types/float64, y : std/core/types/float64) -> std/core/types/float64;
// Returns the smallest element of a list of integers (or `default` (=`0`) for the empty list)
pub fun minimum : (xs : (list :: V -> V)<std/core/types/int>, default : (std/core/types/optional :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Returns the smallest element of a list of floats (or `0` for the empty list)
pub fun minimum.1 : (xs : (list :: V -> V)<std/core/types/float64>) -> std/core/types/float64;
// Disable tracing completely.
fun notrace : () -> <(std/core/types/st :: H -> E)<(std/core/types/global :: H)>> ();
// Transform a `:maybe` type to a `:null` type (using `null` for `Nothing`).
pub fun null : forall<a> (x : (std/core/types/maybe :: V -> V)<a>) -> (null :: V -> V)<a>;
// Cast a integer that is zero to a null
pub fun null.1 : (i : std/core/types/int) -> (null :: V -> V)<std/core/types/int>;
// Cast an empty string a null
pub fun null.2 : (s : std/core/types/string) -> (null :: V -> V)<std/core/types/string>;
// Cast a boolean `False` to null
pub fun null.3 : (b : std/core/types/bool) -> (null :: V -> V)<()>;
// Left-align a string to width `width`  using `fill`  (default is a space) to fill on the right.
pub fun pad-right : (s : std/core/types/string, ^ width : std/core/types/int, fill : (std/core/types/optional :: V -> V)<std/core/types/char>) -> std/core/types/string;
// Is `pre`  a prefix of `s`? If so, returns a slice
// of `s` following `pre` up to the end of `s`.
pub fun starts-with : (s : std/core/types/string, pre : std/core/types/string) -> (std/core/types/maybe :: V -> V)<sslice>;
// Trim off a substring `sub` while `s` starts with that string.
pub fun trim-left.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/string;
// Trim off a substring `sub` while `s` ends with that string.
pub fun trim-right.1 : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/string;
// Trim whitespace on the left and right side of a string
pub fun trim : (s : std/core/types/string) -> std/core/types/string;
// Parse an integer after trimming whitespace.
// If an illegal digit character is encountered `Nothing` is returned.
// An empty string will result in `Just(0)`.
// A string can start with a `-` sign for negative numbers,
// and with `0x` or `0X` for hexadecimal numbers (in which case the `hex` parameter is ignored).
pub fun parse-int : (s : std/core/types/string, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> (std/core/types/maybe :: V -> V)<std/core/types/int>;
// Parse an integer using `parseInt`. If an illegal digit character is encountered the
// `default` value is returned. An empty string will also result in `default`.
pub fun parse-int-default : (s : std/core/types/string, default : (std/core/types/optional :: V -> V)<std/core/types/int>, hex : (std/core/types/optional :: V -> V)<std/core/types/bool>) -> std/core/types/int;
// monadic lift
fun .mlift17728-partition-acc : forall<a,(e :: E)> (acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17570 : std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
fun partition-acc : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool, acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<a>) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Partition a list in two lists where the first list contains
// those elements that satisfy the given predicate `pred`.
// For example: `partition([1,2,3],odd?) == ([1,3],[2])`
pub fun partition : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, pred : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// redirect `print` and `println` calls to a specified function.
fun print-redirect : (print : (msg : std/core/types/string) -> <(console :: X)> ()) -> <(io :: E)> ();
// Remove those elements of a list that satisfy the given predicate `pred`.
// For example: `remove([1,2,3],odd?) == [2]`
pub fun remove : forall<a> (xs : (list :: V -> V)<a>, pred : (a) -> std/core/types/bool) -> (list :: V -> V)<a>;
// Repeat a string `n` times
pub fun repeat : (s : std/core/types/string, ^ n : std/core/types/int) -> std/core/types/string;
// The `repeat` fun executes `action`  `n`  times.
pub fun repeat.1 : forall<(e :: E)> (^ n : std/core/types/int, action : () -> (e :: E) ()) -> (e :: E) ();
// Create a list of `n`  repeated elementes `x`
pub fun .ctail-replicate : forall<a> (x : a, n : std/core/types/int, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (list :: V -> V)<a>;
// Create a list of `n`  repeated elementes `x`
pub fun replicate : forall<a> (x : a, n : std/core/types/int) -> (list :: V -> V)<a>;
// lifted local: reverse-join, reverse-acc
fun .lift17200-reverse-join : forall<a> (acc : (list :: V -> V)<a>, ys : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted local: reverse-join, join-acc
fun .lift17201-reverse-join : (ys0 : (list :: V -> V)<std/core/types/string>, acc0 : std/core/types/string) -> std/core/types/string;
// Concatenate all strings in a list in reverse order
pub fun reverse-join : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
pub fun show-tuple : forall<a,b> (x : (a, b), showfst : (a) -> std/core/types/string, showsnd : (b) -> std/core/types/string) -> std/core/types/string;
// monadic lift
fun .mlift17729-op : forall<a,(e :: E)> (acc : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, y : a, ys : (list :: V -> V)<a>, yy : (list :: V -> V)<a>, .y.17578 : std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// lifted local: span, span-acc
// todo: implement TRMC with multiple results to avoid the reverse
fun .lift17202-span : forall<a,(e :: E)> (predicate : (a) -> (e :: E) std/core/types/bool, ys : (list :: V -> V)<a>, acc : (list :: V -> V)<a>) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
pub fun span : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>);
// Return the sum of a list of integers
pub fun sum : (xs : (list :: V -> V)<std/core/types/int>) -> std/core/types/int;
// Return the tail of list. Returns the empty list if `xs` is empty.
pub fun tail.1 : forall<a> (xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// Return the tail of a string (or the empty string)
pub fun tail.2 : (s : std/core/types/string) -> std/core/types/string;
// monadic lift
fun .mlift17730-op : forall<a,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17583 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17731-op : forall<a,(e :: E)> (.accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, x : a, xx : (list :: V -> V)<a>, .y.17587 : std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
pub fun .ctail-take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<a>>) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
pub fun .ctailm-take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool, .accm : ((list :: V -> V)<a>) -> (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>;
// Keep only those initial elements that satisfy `predicate`
pub fun take-while : forall<a,(e :: E)> (xs : (list :: V -> V)<a>, predicate : (a) -> (e :: E) std/core/types/bool) -> (e :: E) (list :: V -> V)<a>;
// monadic lift
fun .mlift17732-trace : forall<(_e :: E)> (message0 : std/core/types/string, .y.17594 : std/core/types/bool) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> ();
// Trace a message used for debug purposes.
// The behaviour is system dependent. On a browser and node it uses
// `console.log`  by default.
// Disabled if `notrace` is called.
pub fun trace : (message : std/core/types/string) -> ();
// monadic lift
fun .mlift17733-trace-any : forall<(_e :: E),a> (message0 : std/core/types/string, x : a, .y.17596 : std/core/types/bool) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> ();
pub fun trace-any : forall<a> (message : std/core/types/string, x : a) -> ();
// Truncate a string to `count` characters.
pub fun truncate : (s : std/core/types/string, count : std/core/types/int) -> std/core/types/string;
// Return a default value when an exception is raised
pub fun try-default : forall<a,(e :: E)> (value : a, action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a;
// monadic lift
fun .mlift17734-unique : forall<(_e :: E)> (u : std/core/types/int) -> <(std/core/types/read :: H -> X)<(std/core/types/global :: H)>,(std/core/types/write :: H -> X)<(std/core/types/global :: H)>|(_e :: E)> std/core/types/int;
// Returns a unique integer (modulo 32-bits).
pub fun unique : () -> <(std/core/types/ndet :: X)> std/core/types/int;
// Get the value of the `Just` constructor or raise an exception
pub fun unjust : forall<a> (m : (std/core/types/maybe :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a;
// lifted local: unlines, join-acc
fun .lift17203-unlines : (ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string;
// Join a list of strings with newlines
pub fun unlines : (xs : (list :: V -> V)<std/core/types/string>) -> std/core/types/string;
// lifted local: .lift17204-unzip, unzip, reverse-acc
fun .lift17205-unzip : forall<a> (acc : (list :: V -> V)<a>, ys0 : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted local: .lift17204-unzip, unzip, reverse-acc0
fun .lift17206-unzip : forall<a> (acc0 : (list :: V -> V)<a>, ys1 : (list :: V -> V)<a>) -> (list :: V -> V)<a>;
// lifted local: unzip, iter
// todo: implement TRMC for multiple results
fun .lift17204-unzip : forall<a,b> (ys : (list :: V -> V)<(a, b)>, acc1 : (list :: V -> V)<a>, acc2 : (list :: V -> V)<b>) -> ((list :: V -> V)<a>, (list :: V -> V)<b>);
// Unzip a list of pairs into two lists
pub fun unzip : forall<a,b> (xs : (list :: V -> V)<(a, b)>) -> ((list :: V -> V)<a>, (list :: V -> V)<b>);
// Convert a string to a vector of characters.
pub fun vector.1 : (s : std/core/types/string) -> (std/core/types/vector :: V -> V)<std/core/types/char>;
// Create a new vector of length `n`  with initial elements `default` .
pub fun vector.2 : forall<a> (^ n : std/core/types/int, default : a) -> (std/core/types/vector :: V -> V)<a>;
// Convert a list to a vector.
pub fun vector.3 : forall<a> (xs : (list :: V -> V)<a>) -> (std/core/types/vector :: V -> V)<a>;
// Create a new vector of length `n`  with initial elements given by function `f` .
pub fun vector-init : forall<a> (^ n : std/core/types/int, f : (std/core/types/int) -> a) -> (std/core/types/vector :: V -> V)<a>;
// monadic lift
fun .mlift17735-while : forall<(e :: E)> (action : () -> <(std/core/types/div :: X)|(e :: E)> (), predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, wild_ : ()) -> <(std/core/types/div :: X)|(e :: E)> ();
// monadic lift
fun .mlift17736-while : forall<(e :: E)> (action : () -> <(std/core/types/div :: X)|(e :: E)> (), predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, .y.17602 : std/core/types/bool) -> <(std/core/types/div :: X)|(e :: E)> ();
// The `while` fun executes `action`  as long as `pred`  is `true`.
pub fun while : forall<(e :: E)> (predicate : () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, action : () -> <(std/core/types/div :: X)|(e :: E)> ()) -> <(std/core/types/div :: E)|(e :: E)> ();
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun .ctail-zip : forall<a,b> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<(a, b)>>) -> (list :: V -> V)<(a, b)>;
// Zip two lists together by pairing the corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun zip : forall<a,b> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>) -> (list :: V -> V)<(a, b)>;
// monadic lift
fun .mlift17737-op : forall<a,b,c,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>, f : (a, b) -> (e :: E) c, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17316 : c) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
fun .mlift17738-op : forall<a,b,c,(e :: E)> (.accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>, f : (a, b) -> (e :: E) c, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17321 : c) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun .ctail-zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun .ctailm-zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c, .accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements.
// The returned list is only as long as the smallest input list.
pub fun zipwith : forall<a,b,c,(e :: E)> (xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, f : (a, b) -> (e :: E) c) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
fun .mlift17739-op : forall<a,b,c,(e :: E)> (.acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>, f : (std/core/types/int, a, b) -> (e :: E) c, i0.17233 : std/core/types/int, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17322 : c) -> (e :: E) (list :: V -> V)<c>;
// monadic lift
fun .mlift17740-op : forall<a,b,c,(e :: E)> (.accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>, f : (std/core/types/int, a, b) -> (e :: E) c, i0.17233 : std/core/types/int, xx : (list :: V -> V)<a>, yy : (list :: V -> V)<b>, .ctail.17327 : c) -> (e :: E) (list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
fun .ctail-lift17207-zipwith-indexed : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, .acc : (std/core/types/ctail :: V -> V)<(list :: V -> V)<c>>) -> (e :: E) (list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
fun .ctailm-lift17207-zipwith-indexed : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>, .accm : ((list :: V -> V)<c>) -> (list :: V -> V)<c>) -> (e :: E) (list :: V -> V)<c>;
// lifted local: zipwith-indexed, zipwith-iter
fun .lift17207-zipwith-indexed : forall<a,b,c,(e :: E)> (f : (std/core/types/int, a, b) -> (e :: E) c, i : std/core/types/int, xs : (list :: V -> V)<a>, ys : (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<c>;
// Zip two lists together by apply a function `f` to all corresponding elements
// and their index in the list.
// The returned list is only as long as the smallest input list.
pub fun zipwith-indexed : forall<a,b,c,(e :: E)> (xs0 : (list :: V -> V)<a>, ys0 : (list :: V -> V)<b>, f : (std/core/types/int, a, b) -> (e :: E) c) -> (e :: E) (list :: V -> V)<c>;
 
//------------------------------
//#kki: external declarations
 
// Add the state effect to a function effect.
pub extern inject-st : forall<a,(h :: H),(e :: E)> (() -> (e :: E) a) -> (total :: E) (() -> <(std/core/types/st :: H -> E)<(h :: H)>|(e :: E)> a) = inline "#1";
pub extern (==) : (std/core/types/char, std/core/types/char) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
pub extern (!=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
pub extern (<=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 <= #2)";
pub extern (>=) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 >= #2)";
pub extern (<) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 < #2)";
pub extern (>) : (std/core/types/char, std/core/types/char) -> std/core/types/bool = inline "(#1 > #2)";
// Convert a character to its unicode code point
pub extern int : (std/core/types/char) -> std/core/types/int {
  inline "#1";
  c inline "kk_integer_from_int(#1,kk_context())";
  cs inline "new BigInteger(#1)";
};
// Convert a unicode code point to a character
pub extern char : (i : std/core/types/int) -> std/core/types/char {
  inline "(#1)";
  c inline "kk_integer_clamp32(#1,kk_context())";
  cs inline "Primitive.IntToInt32(#1)";
};
// Compare two integers
pub extern compare : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/order {
  c inline "kk_int_as_order(kk_integer_cmp_borrow(#1,#2,kk_context()),kk_context())";
  cs inline "Primitive.IntCompare(#1,#2)";
  js inline "$std_core._int_compare(#1,#2)";
};
// Are two integers equal?
pub extern (==.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_eq_borrow(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "$std_core._int_eq(#1,#2)";
};
// Are two integers not equal?
pub extern (!=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_neq_borrow(#1,#2,kk_context())";
  cs inline "(#1 != #2)";
  js inline "$std_core._int_ne(#1,#2)";
};
// Is the first integer smaller or equal to the second?
pub extern (<=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_lte_borrow(#1,#2,kk_context())";
  cs inline "(#1 <= #2)";
  js inline "$std_core._int_le(#1,#2)";
};
// Is the first integer greater or equal to the second?
pub extern (>=.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_gte_borrow(#1,#2,kk_context())";
  cs inline "(#1 >= #2)";
  js inline "$std_core._int_ge(#1,#2)";
};
// Is the first integer smaller than the second?
pub extern (<.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_lt_borrow(#1,#2,kk_context())";
  cs inline "(#1 < #2)";
  js inline "$std_core._int_lt(#1,#2)";
};
// Is the first integer greater than the second?
pub extern (>.1) : (^ x : std/core/types/int, ^ y : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_gt_borrow(#1,#2,kk_context())";
  cs inline "(#1 > #2)";
  js inline "$std_core._int_gt(#1,#2)";
};
extern int-add : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_add(#1,#2,kk_context())";
  cs inline "(#1 + #2)";
  js inline "$std_core._int_add(#1,#2)";
};
extern int-sub : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_sub(#1,#2,kk_context())";
  cs inline "(#1 - #2)";
  js inline "$std_core._int_sub(#1,#2)";
};
// Multiply two integers.
pub extern (*) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_mul(#1,#2,kk_context())";
  cs inline "(#1 * #2)";
  js inline "$std_core._int_mul(#1,#2)";
};
// Euclidean-0 division of two integers. See also `divmod:(x : int, y : int) -> (int,int)`.
pub extern (/) : (x : std/core/types/int, y : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_div(#1,#2,kk_context())";
  cs inline "Primitive.IntDiv(#1,#2)";
  js inline "$std_core._int_div(#1,#2)";
};
// Euclidean modulus of two integers; always a non-negative number. See also `divmod:(x : int, y : int) -> (int,int)`.
pub extern (%) : (std/core/types/int, std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_mod(#1,#2,kk_context())";
  cs inline "Primitive.IntMod(#1,#2)";
  js inline "$std_core._int_mod(#1,#2)";
};
// Euclidean-0 division & modulus.
// Euclidean division is defined as: For any `D`  and `d`  where `d!=0` , we have:
//
// 1. `D == d*(D/d) + (D%d)`
// 2. `D%d`  is always positive where `0 <= D%d < abs(d)`
//
// Moreover, Euclidean-0 is a total function, for the case where `d==0`  we have
// that `D%0 == D`  and `D/0 == 0` . So property (1) still holds, but not property (2).
//
// Useful laws that hold for Euclidean-0 division:
//
// * `D/(-d) == -(D/d)`
// * `D%(-d) == D%d`
// * `D/(2^n) == sar(D,n)         `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
// * `D%(2^n) == D & ((2^n) - 1)  `  (with `0 <= n <= 31`  and `2^n`  means `2`  to the power of `n` )
//
// See also _Division and modulus for computer scientists, Daan Leijen, 2001_ for further information
// available at: <http://research.microsoft.com/pubs/151917/divmodnote.pdf> .
pub extern divmod : (x : std/core/types/int, y : std/core/types/int) -> (std/core/types/int, std/core/types/int) {
  c inline "kk_integer_div_mod_tuple(#1,#2,kk_context())";
  cs inline "Primitive.IntDivMod(#1,#2)";
  js inline "$std_core._int_divmod(#1,#2)";
};
// Negate an integer.
pub extern (~) : (i : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_neg(#1,kk_context())";
  cs inline "(-#1)";
  js inline "$std_core._int_negate(#1)";
};
// Convert an integer to a `:float64`. May return `nan` if the integer is too large to represent as a `:float64`.
pub extern float64 : (i : std/core/types/int) -> std/core/types/float64 {
  c inline "kk_integer_as_double(#1,kk_context())";
  cs inline "Primitive.IntToDouble(#1)";
  js inline "$std_core._int_to_double(#1)";
};
// Convert an integer to a `:float32`. May return `nan` if the integer is too large to represent as a `:float32`.
pub extern float32 : (i : std/core/types/int) -> std/core/types/float32 {
  c inline "kk_integer_as_float(#1,kk_context())";
  cs inline "Primitive.IntToFloat(#1)";
  js inline "$std_core._int_to_float(#1)";
};
// Is this an odd integer?
pub extern is-odd : (i : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_is_odd(#1,kk_context())";
  cs inline "!(#1.IsEven)";
  js inline "$std_core._int_isodd(#1)";
};
// Is this equal to zero?
pub extern is-zero : (^ x : std/core/types/int) -> std/core/types/bool {
  c inline "kk_integer_is_zero_borrow(#1)";
  cs inline "(#1.IsZero)";
  js inline "$std_core._int_iszero(#1)";
};
// Return the absolute value of an integer.
pub extern abs : (i : std/core/types/int) -> std/core/types/int {
  c inline "kk_integer_abs(#1,kk_context())";
  cs inline "BigInteger.Abs(#1)";
  js inline "$std_core._int_abs(#1)";
};
pub extern sign : (^ i : std/core/types/int) -> std/core/types/order {
  c inline "kk_int_as_order(kk_integer_signum_borrow(#1),kk_context())";
  cs inline "Primitive.IntSign(#1)";
  js inline "$std_core._int_sign(#1)";
};
// Convert an `:int32` to an `:int`.
pub extern int.1 : (i : std/core/types/int32) -> std/core/types/int {
  c inline "kk_integer_from_int(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Minimal set of operations that we need in `std/core`.
extern (<=.2) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 <= #2)";
  js inline "(#1 <= #2)";
};
extern (<.2) : (std/core/types/int32, std/core/types/int32) -> std/core/types/bool {
  inline "(#1 < #2)";
  js inline "(#1 < #2)";
};
extern (+) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
};
extern (-) : (std/core/types/int32, std/core/types/int32) -> std/core/types/int32 {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
};
extern is-pos : (i : std/core/types/int32) -> std/core/types/bool = inline "(#1>0)";
extern is-neg : (i : std/core/types/int32) -> std/core/types/bool = inline "(#1<0)";
// Convert an `:ssize_t` to an `:int`.
pub extern int.2 : (i : std/core/types/ssize_t) -> std/core/types/int {
  c inline "kk_integer_from_ssize_t(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Minimal set of operations that we need in `std/core`.
extern (<=.3) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 <= #2)";
extern (>=.2) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 >= #2)";
extern (<.3) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 < #2)";
extern (+.1) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/ssize_t {
  inline "(#1 + #2)";
  js inline "((#1 + #2)|0)";
};
extern (-.1) : (std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/ssize_t {
  inline "(#1 - #2)";
  js inline "((#1 - #2)|0)";
};
extern is-pos.1 : (i : std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 > 0)";
extern is-neg.1 : (i : std/core/types/ssize_t) -> std/core/types/bool = inline "(#1 < 0)";
// Convert an `:int8` to an `:int`.
pub extern int.3 : (i : std/core/types/int8) -> std/core/types/int {
  c inline "kk_integer_from_int8(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Convert an `:int8` to an `:int` but interpret the `:int8` as an unsigned 8-bit value between 0 and 255.
pub extern uint : (i : std/core/types/int8) -> std/core/types/int {
  c inline "kk_integer_from_uint8(#1,kk_context())";
  cs inline "(new BigInteger(#1 >= 0 ? #1 : 256 + #1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Convert an `:int16` to an `:int`.
pub extern int.4 : (i : std/core/types/int16) -> std/core/types/int {
  c inline "kk_integer_from_int16(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int32(#1)";
};
// Convert an `:int64_t` to an `:int`.
pub extern int.5 : (i : std/core/types/int64) -> std/core/types/int {
  c inline "kk_integer_from_int64(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int64(#1)";
};
// Convert an `:intptr_t` to an `:int`.
pub extern int.6 : (i : std/core/types/intptr_t) -> std/core/types/int {
  c inline "kk_integer_from_intptr_t(#1,kk_context())";
  cs inline "(new BigInteger(#1))";
  js inline "$std_core._int_from_int64(#1)";
};
pub extern (==.2) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool {
  inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
pub extern (!=.2) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool {
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
pub extern (<=.4) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool = inline "(#1 <= #2)";
pub extern (>=.3) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool = inline "(#1 >= #2)";
pub extern (<.4) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool = inline "(#1 < #2)";
pub extern (>.2) : (std/core/types/float64, std/core/types/float64) -> std/core/types/bool = inline "(#1 > #2)";
pub extern (+.2) : (std/core/types/float64, std/core/types/float64) -> std/core/types/float64 = inline "(#1 + #2)";
pub extern (-.2) : (std/core/types/float64, std/core/types/float64) -> std/core/types/float64 = inline "(#1 - #2)";
pub extern (*.1) : (std/core/types/float64, std/core/types/float64) -> std/core/types/float64 = inline "(#1 * #2)";
pub extern (/.1) : (std/core/types/float64, std/core/types/float64) -> std/core/types/float64 = inline "(#1 / #2)";
pub extern (%.1) : (std/core/types/float64, std/core/types/float64) -> std/core/types/float64 {
  c inline "fmod(#1,#2)";
  inline "(#1 % #2)";
};
// Negate a `:float64`.
pub extern (~.1) : (f : std/core/types/float64) -> std/core/types/float64 = inline "(-#1)";
// convert a `:float64` to an `:int` using `round` to round to its nearest integer.
// (rounding to an even number on a tie)
// Returns `0` if the argument is not `finite?`.
pub extern int.7 : (f : std/core/types/float64) -> std/core/types/int {
  c inline "kk_integer_from_double(#1,kk_context())";
  cs inline "Primitive.IntDouble(#1)";
  js inline "$std_core._int_double(#1)";
};
// Returns the value `f`  raised to the power `p` .
pub extern (^) : (f : std/core/types/float64, p : std/core/types/float64) -> std/core/types/float64 {
  c inline "pow(#1,#2)";
  cs inline "Math.Pow(#1,#2)";
  js inline "Math.pow(#1,#2)";
};
// Return the absolute value of a `:float64` `f`
pub extern abs.1 : (f : std/core/types/float64) -> std/core/types/float64 {
  c inline "kk_double_abs(#1)";
  cs inline "Math.Abs(#1)";
  js inline "Math.abs(#1)";
};
// Are two strings equal?
// Uses exact equality between character codes.
pub extern (==.3) : (std/core/types/string, std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_is_eq(#1,#2,kk_context())";
  cs inline "(#1 == #2)";
  js inline "(#1 === #2)";
};
// Are two strings not equal?
pub extern (!=.3) : (std/core/types/string, std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_is_neq(#1,#2,kk_context())";
  inline "(#1 != #2)";
  js inline "(#1 !== #2)";
};
// Length returns the length in the platform specific encoding (and should not be exported)
extern length : (s : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_len(#1,kk_context())";
  cs inline "#1.Length";
  js inline "#1.length";
};
// Does string `s`  contain the string `sub`  ?
extern xindex-of : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_index_of1(#1,#2,kk_context())";
  cs inline "((#1).IndexOf(#2) + 1)";
  js inline "((#1).indexOf(#2) + 1)";
};
// Does string `s`  contain the string `sub`  ?
extern xlast-index-of : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/ssize_t {
  c inline "kk_string_last_index_of1(#1,#2,kk_context())";
  cs inline "(#1.LastIndexOf(#2) + 1)";
  js inline "((#1).lastIndexOf(#2) + 1)";
};
extern xstarts-with : (s : std/core/types/string, pre : std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_starts_with(#1,#2,kk_context())";
  cs inline "#1.StartsWith(#2)";
  js inline "(#1.substr(0,#2.length) === #2)";
};
// Does string `s`  contain the string `sub`  ?
pub extern contains : (s : std/core/types/string, sub : std/core/types/string) -> std/core/types/bool {
  c inline "kk_string_contains(#1,#2,kk_context())";
  cs inline "((#1).Contains(#2))";
  js inline "((#1).indexOf(#2) >= 0)";
};
// Concatenate a vector of strings
pub extern join : (v : (std/core/types/vector :: V -> V)<std/core/types/string>) -> std/core/types/string {
  c inline "kk_string_join(#1,kk_context())";
  cs inline "String.Concat(#1)";
  js inline "((#1).join(\x27\x27))";
};
// Concatenate a vector of strings with a separator `sep`
pub extern join.1 : (v : (std/core/types/vector :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> (total :: E) std/core/types/string {
  c inline "kk_string_join_with(#1,#2,kk_context())";
  cs inline "Primitive.Concat(#1,#2)";
  js inline "((#1).join(#2))";
};
extern splitv : (s : std/core/types/string, sep : std/core/types/string) -> (std/core/types/vector :: V -> V)<std/core/types/string> {
  c inline "kk_string_splitv(#1,#2,kk_context())";
  cs inline "(#1.Split(new String[]{#2}, StringSplitOptions.None))";
  js inline "((#1).split(#2))";
};
extern splitv.1 : (s : std/core/types/string, sep : std/core/types/string, n : std/core/types/ssize_t) -> (std/core/types/vector :: V -> V)<std/core/types/string> {
  c inline "kk_string_splitv_atmost(#1,#2,#3,kk_context())";
  cs inline "#1.Split(new String[]{#2},#3, StringSplitOptions.None)";
  js inline "(#1).split(#2, #3)";
};
// Replace every occurrence of `pattern` to `repl` in a string.
pub extern replace-all : (s : std/core/types/string, pattern : std/core/types/string, repl : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_replace_all(#1,#2,#3,kk_context())";
  cs inline "(#1).Replace(#2,#3)";
  js inline "(#1).replace(new RegExp((#2).replace(/[\x5C\x5C\x5C$\x5C^*+\x5C-{}?().]/g,\x27\x5C\x5C$&\x27),\x27g\x27),#3)";
};
// Count occurences of `pattern` in a string.
pub extern count : (s : std/core/types/string, pattern : std/core/types/string) -> std/core/types/int {
  c inline "kk_string_count_pattern(#1,#2,kk_context())";
  cs inline "Primitive.Count(#1,#2)";
  js inline "((#2) ? ((#1).match(new RegExp((#2).replace(/[\x5C\x5C\x5C$\x5C^*+\x5C-{}?().]/g,\x27\x5C\x5C$&\x27),\x27g\x27))||[]).length : 0)";
};
// Trim the starting white space of a string
pub extern trim-left : (s : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_trim_left(#1,kk_context())";
  cs inline "(#1).TrimStart()";
  js inline "((#1).replace(/^\x5Cs\x5Cs*/,\x27\x27))";
};
// Trim the ending white space of a string.
pub extern trim-right : (s : std/core/types/string) -> std/core/types/string {
  c inline "kk_string_trim_right(#1,kk_context())";
  cs inline "(#1).TrimEnd()";
  js inline "((#1).replace(/\x5Cs+$/,\x27\x27))";
};
// Return the element at position `index`  in vector `v`  without bounds check!
extern unsafe-idx : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (total :: E) a {
  c inline "kk_vector_at_borrow(#1,#2)";
  cs inline "(#1)[#2]";
  js inline "(#1)[#2]";
};
extern unsafe-assign : forall<a> (v : (std/core/types/vector :: V -> V)<a>, i : std/core/types/ssize_t, x : a) -> (total :: E) () {
  c inline "kk_vector_unsafe_assign(#1,#2,#3,kk_context())";
  cs inline "(#1)[#2] = #3";
  js inline "(#1)[#2] = #3";
};
extern unsafe-vector : forall<a> (n : std/core/types/ssize_t) -> (total :: E) (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_alloc_uninit(#1,NULL,kk_context())";
  cs inline "(new ##1[#1])";
  js inline "Array(#1)";
};
// Return the element at position `index`  in vector `v` . Raise an out of bounds exception if `index < 0`  or `index >= v.length` .
pub extern ([]) : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>, ^ index : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a {
  c inline "kk_vector_at_int_borrow(#1,#2,kk_context())";
  cs inline "(#1)[Primitive.IntToInt32(#2)]";
  js inline "$std_core._vector_at(#1,#2)";
};
extern lengthz : forall<a> (^ v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t {
  c inline "kk_vector_len_borrow(#1)";
  cs inline "((#1).Length)";
  js inline "((#1).length)";
};
// Create an empty vector.
pub extern vector : forall<a> () -> (std/core/types/vector :: V -> V)<a> {
  c inline "kk_vector_empty()";
  cs inline "new ##1[0]";
  js inline "[]";
};
// _Unsafe_. This function removes the non-termination effect (`:div`) from the effect of an action
pub extern unsafe-nostate : forall<a,(h :: H)> (action : () -> <(std/core/types/st :: H -> E)<(h :: H)>,(console :: X)> a) -> (() -> <(console :: X)> a) = inline "#1";
pub extern inject-local : forall<a,(e :: E),(h :: H)> (action : () -> (e :: E) a) -> (total :: E) (() -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> a) = inline "#1";
// Assign to an entry in a local `:vector` variable.
pub extern ([].1) : forall<a,(e :: E),(h :: H)> (^ self : (std/core/types/local-var :: (H, V) -> V)<(h :: H),(std/core/types/vector :: V -> V)<a>>, ^ index : std/core/types/int, assigned : a) -> <(std/core/types/local :: H -> X)<(h :: H)>,(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> () {
  c inline "kk_ref_vector_assign_borrow(#1,#2,#3,kk_context())";
  cs inline "(#1)[(int)#2] = #3";
  js inline "(#1)[#2] = #3";
};
// Magic casting to the `:any` type.
pub extern .toany : forall<a> (x : a) -> std/core/types/any {
  inline "#1";
  cs inline "(object)(#1)";
};
 
//------------------------------
//#kki: inline definitions
 
//.inline-section
recursive specialize "*__" fun .lift17184-flatmap // inline size: 8
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (a) -> (e :: E) (list :: V -> V)<b>, ys: (list :: V -> V)<b>, zs: (list :: V -> V)<a>){
    (match (ys) {
      ((std/core/Cons((y: b) : b, (yy: (list :: V -> V)<b>) : (list :: V -> V)<b>) : (list :: V -> V)<b> ) as .pat: ((list :: V -> V)<b>))
         -> std/core/Cons<b>(y, ((fn<(e :: E)>(ys: (list :: V -> V)<b>, zs: (list :: V -> V)<a>){
            std/core/.lift17184-flatmap<a,b,(e :: E)>(f, ys, zs);
          })(yy, zs)));
      ((.skip std/core/Nil() : (list :: V -> V)<b> ) as .pat0: ((list :: V -> V)<b>))
         -> (match (zs) {
          ((std/core/Cons((z: a) : a, (zz: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
             -> (fn<(e :: E)>(ys: (list :: V -> V)<b>, zs: (list :: V -> V)<a>){
              std/core/.lift17184-flatmap<a,b,(e :: E)>(f, ys, zs);
            })((f(z)), zz);
          ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
             -> std/core/Nil<b>;
        });
    });
  };
recursive specialize "*_" fun .lift17187-map-peek // inline size: 5
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys: (list :: V -> V)<a>){
    (match (ys) {
      ((std/core/Cons((y: a) : a, (yy: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Cons<b>((f(y, yy)), ((fn<(e :: E)>(ys: (list :: V -> V)<a>){
            std/core/.lift17187-map-peek<a,b,(e :: E)>(f, ys);
          })(yy)));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "*__" fun .lift17190-forz // inline size: 10
  = forall<(e :: E)> fn<(e :: E)>(action: (std/core/types/ssize_t) -> (e :: E) (), end: std/core/types/ssize_t, i: std/core/types/ssize_t){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool,(std/core/types/ssize_t, std/core/types/ssize_t) -> (e :: E) std/core/types/bool>(std/core/(<=.3))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> val _ : ()
                  = action(i);
        (fn<(e :: E)>(i: std/core/types/ssize_t){
          std/core/.lift17190-forz<(e :: E)>(action, end, i);
        })((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/ssize_t) -> std/core/types/ssize_t,(x : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>((std/core/types/unsafe-decreasing<std/core/types/ssize_t>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/ssize_t,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>(std/core/incr.1)(i)))));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/();
    });
  };
recursive specialize "*__" fun .lift17194-for-whilez // inline size: 12
  = forall<a,(e :: E)> fn<(e :: E)>(action: (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end: std/core/types/ssize_t, i: std/core/types/ssize_t){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(std/core/types/ssize_t, std/core/types/ssize_t) -> std/core/types/bool,(std/core/types/ssize_t, std/core/types/ssize_t) -> (e :: E) std/core/types/bool>(std/core/(<=.3))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match ((action(i))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
             -> (fn<(e :: E)>(i: std/core/types/ssize_t){
              std/core/.lift17194-for-whilez<a,(e :: E)>(action, end, i);
            })((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/ssize_t) -> std/core/types/ssize_t,(x : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>((std/core/types/unsafe-decreasing<std/core/types/ssize_t>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/ssize_t,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>(std/core/incr.1)(i)))));
          ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat1: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core/types/Just<a>(x);
        });
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/core/types/Nothing<a>;
    });
  };
recursive specialize "*__" fun .lift17196-for // inline size: 11
  = forall<(e :: E)> fn<(e :: E)>(action: (std/core/types/int) -> (e :: E) (), end: std/core/types/int, i: std/core/types/int){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> val _ : ()
                  = action(i);
        (fn<(e :: E)>(i: std/core/types/int){
          std/core/.lift17196-for<(e :: E)>(action, end, i);
        })((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i0: std/core/types/int){
          (std/core/int-add(i0, 1));
        }))(i)))));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/();
    });
  };
recursive specialize "*__" fun .lift17197-for-while // inline size: 13
  = forall<a,(e :: E)> fn<(e :: E)>(action: (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>, end: std/core/types/int, i: std/core/types/int){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(i, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match ((action(i))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
             -> (fn<(e :: E)>(i: std/core/types/int){
              std/core/.lift17197-for-while<a,(e :: E)>(action, end, i);
            })((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i0: std/core/types/int){
              (std/core/int-add(i0, 1));
            }))(i)))));
          ((.skip std/core/types/Just((x0: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat1: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core/types/Just<a>(x0);
        });
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
         -> std/core/types/Nothing<a>;
    });
  };
recursive specialize "*__" fun .lift17198-map-indexed // inline size: 8
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a) -> (e :: E) b, ys: (list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/Cons((y: a) : a, (yy: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Cons<b>((f(i, y)), ((fn<(e :: E)>(ys: (list :: V -> V)<a>, i: std/core/types/int){
            std/core/.lift17198-map-indexed<a,b,(e :: E)>(f, ys, i);
          })(yy, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y0: std/core/types/int){
              (std/core/int-add(x, y0));
            }))(i, 1)))));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "*__" fun .lift17199-map-indexed-peek // inline size: 8
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b, ys: (list :: V -> V)<a>, i: std/core/types/int){
    (match (ys) {
      ((std/core/Cons((y: a) : a, (yy: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Cons<b>((f(i, y, yy)), ((fn<(e :: E)>(ys: (list :: V -> V)<a>, i: std/core/types/int){
            std/core/.lift17199-map-indexed-peek<a,b,(e :: E)>(f, ys, i);
          })(yy, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y0: std/core/types/int){
              (std/core/int-add(x, y0));
            }))(i, 1)))));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "*__" fun .lift17202-span // inline size: 12
  = forall<a,(e :: E)> fn<(e :: E)>(predicate: (a) -> (e :: E) std/core/types/bool, ys: (list :: V -> V)<a>, acc: (list :: V -> V)<a>){
    (match (ys) {
      ((std/core/Cons((y: a) : a, (yy: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(y))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> (fn<(e :: E)>(ys: (list :: V -> V)<a>, acc: (list :: V -> V)<a>){
              std/core/.lift17202-span<a,(e :: E)>(predicate, ys, acc);
            })(yy, (std/core/Cons<a>(y, acc)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc)), ys);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc)), ys);
    });
  };
recursive specialize "*___" fun .lift17207-zipwith-indexed // inline size: 9
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(f: (std/core/types/int, a, b) -> (e :: E) c, i: std/core/types/int, xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Cons((y: b) : b, (yy: (list :: V -> V)<b>) : (list :: V -> V)<b>) : (list :: V -> V)<b> ) as .pat0: ((list :: V -> V)<b>))
             -> std/core/Cons<c>((f(i, x, y)), ((fn<(e :: E)>(i: std/core/types/int, xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>){
                std/core/.lift17207-zipwith-indexed<a,b,c,(e :: E)>(f, i, xs, ys);
              })((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x0: std/core/types/int, y0: std/core/types/int){
                  (std/core/int-add(x0, y0));
                }))(i, 1)), xx, yy)));
          ((.skip std/core/Nil() : (list :: V -> V)<b> ) as .pat1: ((list :: V -> V)<b>))
             -> std/core/Nil<c>;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<c>;
    });
  };
recursive specialize "_*" fun all // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/all<a,(e :: E)>(xx, predicate);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/False;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
recursive specialize "_*" fun any // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/True;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/any<a,(e :: E)>(xx, predicate);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
specialize "_*" fun count.3 // inline size: 1
  = fn(s: std/core/types/string, pred: (std/core/types/char) -> std/core/types/bool){
    std/core/types/unsafe-no-local-cast<std/core/types/int,(std/core/types/(<>) :: E)>((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(){
      std/core/hnd/local-var<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E),(h :: H)>(0, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(cnt: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
          val slice0.17062 : sslice
            = (std/core/Sslice(s, (std/core/ssize_t(0)), (std/core/length(s))));
          val _0 : ((std/core/types/maybe :: V -> V)<_a>)
            = (std/core/foreach-while.1<_a,<(std/core/types/local :: H -> X)<(h :: H)>>>(slice0.17062, (fn<<(std/core/types/local :: H -> X)<(h :: H)>>>(c: std/core/types/char){
                val _ : ()
                      = (match ((pred(c))) {
                        ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
                           -> val x.17060 : std/core/types/int
                                    = std/core/types/local-get<std/core/types/int,(h :: H),(std/core/types/(<>) :: E)>(cnt);
                          std/core/types/local-set<std/core/types/int,(std/core/types/(<>) :: E),(h :: H)>(cnt, (std/core/int-add(x.17060, 1)));
                        ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
                           -> std/core/types/();
                      });
                (std/core/types/Nothing<_a>);
              })));
          (std/core/types/local-get<std/core/types/int,(h :: H),(std/core/types/(<>) :: E)>(cnt));
        }));
    }))();
  };
recursive specialize "_*" fun drop-while // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/drop-while<a,(e :: E)>(xx, predicate);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> xs;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "_*" fun filter // inline size: 6
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/Cons<a>(x, (std/core/filter<a,(e :: E)>(xx, pred)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/filter<a,(e :: E)>(xx, pred);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "_*" fun filter-map // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/filter-map<a,b,(e :: E)>(xx, pred);
          ((.skip std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/filter-map<a,b,(e :: E)>(xx, pred)));
        });
    });
  };
specialize "_*" fun find // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<a,a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/Just<a>(x);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/Nothing<a>;
        });
      }));
  };
specialize "_*" fun find-maybe // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<a>, pred: (a) -> (std/core/types/maybe :: V -> V)<b>){
    std/core/foreach-while<a,b,(std/core/types/(<>) :: E)>(xs, pred);
  };
specialize "_*" fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) (list :: V -> V)<b>){
    val flatmap-pre : ((list :: V -> V)<b>, (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>
          = fn<(e :: E)>(ys: (list :: V -> V)<b>, zs: (list :: V -> V)<a>){
            std/core/.lift17184-flatmap<a,b,(e :: E)>(f, ys, zs);
          };
    flatmap-pre((std/core/Nil<b>), xs);
  };
recursive specialize "_*" fun flatmap-maybe // inline size: 6
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((f(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat0: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/flatmap-maybe<a,b,(e :: E)>(xx, f)));
          ((.skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/flatmap-maybe<a,b,(e :: E)>(xx, f);
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
recursive specialize "___*" fun fold-int // inline size: 10
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, init0: a, f: (std/core/types/int, a) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(>=.1))(start0, end))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> init0;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> val x : a
                  = f(start0, init0);
        std/core/fold-int<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
            (std/core/int-add(i, 1));
          }))(start0)))), end, x, f);
    });
  };
specialize "__*" fun fold-int.1 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(upto: std/core/types/int, init0: a, f: (std/core/types/int, a) -> (e :: E) a){
    std/core/fold-int<a,(e :: E)>(0, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
        (std/core/int-sub(i, 1));
      }))(upto)), init0, f);
  };
recursive specialize "__*" fun foldl // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, z: b, f: (b, a) -> (e :: E) b){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,b,(e :: E)>(xx, (f(z, x)), f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> z;
    });
  };
specialize "_*" fun foldl1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xs: (list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xx, x, f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/.open<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a>((std/core/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/None<exception-info>));
    });
  };
specialize "__*" fun foldr // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/foldl<a,b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
specialize "_*" fun foldr1 // inline size: 1
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xs: (list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    val xs0.17091 : (list :: V -> V)<a>
          = std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>,(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> (list :: V -> V)<a>>((std/core/reverse<a>))(xs);
    (match (xs0.17091) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xx, x, f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/.open<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a>((std/core/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/None<exception-info>));
    });
  };
specialize "__*" borrow "^__" fun for // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) ()){
    val rep : (i : std/core/types/int) -> (e :: E) ()
          = fn<(e :: E)>(i: std/core/types/int){
            std/core/.lift17196-for<(e :: E)>(action, end, i);
          };
    rep(start0);
  };
specialize "__*" fun for-while // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    val rep : (i : std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>
          = fn<(e :: E)>(i: std/core/types/int){
            std/core/.lift17197-for-while<a,(e :: E)>(action, end, i);
          };
    rep(start0);
  };
specialize "__*" fun for-whilez // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    val rep : (i : std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>
          = fn<(e :: E)>(i: std/core/types/ssize_t){
            std/core/.lift17194-for-whilez<a,(e :: E)>(action, end, i);
          };
    rep(start0);
  };
recursive specialize "_*" fun foreach // inline size: 3
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) ()){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> val _ : ()
                  = action(x);
        std/core/foreach<a,(e :: E)>(xx, action);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/();
    });
  };
specialize "_*" fun foreach-indexed // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (std/core/types/int, a) -> (e :: E) ()){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (() -> (e :: E) ()),(action : forall<(h :: H)> () -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> ()) -> (e :: E) (() -> (e :: E) ())>((std/core/types/unsafe-no-local-cast<(),(e :: E)>))((forall<(h :: H)> fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(){
      std/core/hnd/local-var<std/core/types/int,(),(e :: E),(h :: H)>(0, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(i: (std/core/types/local-var :: (H, V) -> V)<(h :: H),std/core/types/int>){
          (std/core/foreach<a,<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(xs, (fn<<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>(x: a){
              val j : std/core/types/int
                = (std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i));
              val _ : ()
                = (std/core/hnd/.mask-builtin<(),(e :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>>((fn<(e :: E)>(){
                  (action(j, x));
                })));
              (std/core/types/local-set<std/core/types/int,(e :: E),(h :: H)>(i, (std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)>,(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> <(std/core/types/local :: H -> X)<(h :: H)>|(e :: E)> std/core/types/int>((fn(x0: std/core/types/int, y: std/core/types/int){
                  (std/core/int-add(x0, y));
                }))((std/core/types/local-get<std/core/types/int,(h :: H),(e :: E)>(i)), 1))));
            })));
        }));
    }))();
  };
specialize "**" fun foreach-indexed.1 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (std/core/types/int, a) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(i: std/core/types/ssize_t, x: a){
        (f((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/int,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/int>(std/core/int.2)(i)), x));
      }));
  };
specialize "**" fun foreach-indexedz // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (std/core/types/ssize_t, a) -> (e :: E) ()){
    std/core/forz<(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/ssize_t)(0)), (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/ssize_t,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>(std/core/decr.1)((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t,(v : (std/core/types/vector :: V -> V)<a>) -> (e :: E) std/core/types/ssize_t>((std/core/lengthz<a>))(v)))), (fn<(e :: E)>(i: std/core/types/ssize_t){
        (f(i, (std/core/types/.open<(total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (total :: E) a,(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (e :: E) a>((std/core/unsafe-idx<a>))(v, i))));
      }));
  };
recursive specialize "_*" fun foreach-while // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/foreach-while<a,b,(e :: E)>(xx, action);
          (just: ((std/core/types/maybe :: V -> V)<b>))
             -> just;
        });
    });
  };
recursive specialize "_*" fun foreach-while.1 // inline size: 8
  = forall<a,(e :: E)> fn<(e :: E)>(slice0: sslice, action: (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(slice : sslice) -> (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>,(slice : sslice) -> (e :: E) (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>>(std/core/next)(slice0))) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)> ) as .pat: ((std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/types/Just(((.skip std/core/types/(,)((c: std/core/types/char) : std/core/types/char, ((.skip std/core/Sslice((.pat2: std/core/types/string) : std/core/types/string, (.pat3: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat4: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as rest: sslice) : sslice) : (std/core/types/char, sslice) ) as .pat1: (std/core/types/char, sslice)) : (std/core/types/char, sslice)) : (std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)> ) as .pat0: ((std/core/types/maybe :: V -> V)<(std/core/types/char, sslice)>))
         -> (match ((action(c))) {
          ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat5: ((std/core/types/maybe :: V -> V)<a>))
             -> std/core/foreach-while.1<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : sslice) -> sslice,(x : sslice) -> (e :: E) sslice>((std/core/types/unsafe-decreasing<sslice>))(rest)), action);
          (res: ((std/core/types/maybe :: V -> V)<a>))
             -> res;
        });
    });
  };
specialize "_*" fun foreach-while.2 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(s: std/core/types/string, action: (c : std/core/types/char) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/core/foreach-while.1<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(s : std/core/types/string) -> sslice,(s : std/core/types/string) -> (e :: E) sslice>((fn(s0: std/core/types/string){
        (std/core/Sslice(s0, (std/core/ssize_t(0)), (std/core/length(s0))));
      }))(s)), action);
  };
specialize "**" fun foreach-while.3 // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    std/core/for-whilez<b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/ssize_t)(0)), (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/ssize_t,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/ssize_t>(std/core/decr.1)((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/ssize_t,(v : (std/core/types/vector :: V -> V)<a>) -> (e :: E) std/core/types/ssize_t>((std/core/lengthz<a>))(v)))), (fn<(e :: E)>(i: std/core/types/ssize_t){
        (f((std/core/types/.open<(total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (total :: E) a,(v : (std/core/types/vector :: V -> V)<a>, index : std/core/types/ssize_t) -> (e :: E) a>((std/core/unsafe-idx<a>))(v, i))));
      }));
  };
specialize "_*" fun foreach.1 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(slice0: sslice, action: (c : std/core/types/char) -> (e :: E) ()){
    val _0 : (std/core/types/maybe :: V -> V)<_a>
          = std/core/foreach-while.1<_a,(e :: E)>(slice0, (fn<(e :: E)>(c: std/core/types/char){
              val _ : ()
                    = (action(c));
              (std/core/types/Nothing<_a>);
            }));
    std/core/types/();
  };
specialize "_*" fun foreach.2 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, action: (c : std/core/types/char) -> (e :: E) ()){
    val slice0.17055 : sslice
      = std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(s : std/core/types/string) -> sslice,(s : std/core/types/string) -> (e :: E) sslice>((fn(s0: std/core/types/string){
        (std/core/Sslice(s0, (std/core/ssize_t(0)), (std/core/length(s0))));
      }))(s);
    val _0 : (std/core/types/maybe :: V -> V)<_a>
      = std/core/foreach-while.1<_a,(e :: E)>(slice0.17055, (fn<(e :: E)>(c: std/core/types/char){
          val _ : ()
                = (action(c));
          (std/core/types/Nothing<_a>);
        }));
    std/core/types/();
  };
specialize "**" fun foreach.3 // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(._wildcard_1874_26: std/core/types/ssize_t, x: a){
        (f(x));
      }));
  };
specialize "__*" fun forz // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) ()){
    val rep : (i : std/core/types/ssize_t) -> (e :: E) ()
          = fn<(e :: E)>(i: std/core/types/ssize_t){
            std/core/.lift17190-forz<(e :: E)>(action, end, i);
          };
    rep(start0);
  };
specialize "_*" fun index-of // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/index-of-acc<a>(xs, pred, 0);
  };
recursive specialize "_*_" fun index-of-acc // inline size: 5
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool, idx: std/core/types/int){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> idx;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/index-of-acc<a>(xx, pred, (std/core/int-add(idx, 1)));
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> -1;
    });
  };
recursive specialize "__*" fun list.2 // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/Cons<a>((f(lo)), (std/core/list.2<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
              (std/core/int-add(i, 1));
            }))(lo)))), hi, f)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/Nil<a>;
    });
  };
recursive specialize "___*" fun list.3 // inline size: 11
  = forall<a,(e :: E)> fn<(e :: E)>(lo: std/core/types/int, hi: std/core/types/int, stride: std/core/types/int, f: (std/core/types/int) -> (e :: E) a){
    (match ((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/bool,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/bool>(std/core/(<=.1))(lo, hi))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/Cons<a>((f(lo)), (std/core/list.3<a,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int) -> std/core/types/int,(x : std/core/types/int) -> (e :: E) std/core/types/int>((std/core/types/unsafe-decreasing<std/core/types/int>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/int, y : std/core/types/int) -> std/core/types/int,(x : std/core/types/int, y : std/core/types/int) -> (e :: E) std/core/types/int>((fn(x: std/core/types/int, y: std/core/types/int){
              (std/core/int-add(x, y));
            }))(lo, stride)))), hi, stride, f)));
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/Nil<a>;
    });
  };
specialize "_*" fun lookup // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<(a, b)>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<(a, b),b,(std/core/types/(<>) :: E)>(xs, (fn(kv: (a, b)){
        (match ((pred((match (kv) {
          ((.skip std/core/types/(,)((.x: a) : a, (.pat0: b) : b) : (a, b) ) as .pat: (a, b))
             -> .x;
        })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Just<b>((match (kv) {
              ((.skip std/core/types/(,)((.pat00: a) : a, (.x0: b) : b) : (a, b) ) as .pat2: (a, b))
                 -> .x0;
            }));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
             -> std/core/types/Nothing<b>;
        });
      }));
  };
specialize "_*" fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    val map-idx : ((list :: V -> V)<a>, std/core/types/int) -> (e :: E) (list :: V -> V)<b>
          = fn<(e :: E)>(ys: (list :: V -> V)<a>, i: std/core/types/int){
            std/core/.lift17198-map-indexed<a,b,(e :: E)>(f, ys, i);
          };
    map-idx(xs, 0);
  };
specialize "_*" fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    val mapidx : ((list :: V -> V)<a>, std/core/types/int) -> (e :: E) (list :: V -> V)<b>
          = fn<(e :: E)>(ys: (list :: V -> V)<a>, i: std/core/types/int){
            std/core/.lift17199-map-indexed-peek<a,b,(e :: E)>(f, ys, i);
          };
    mapidx(xs, 0);
  };
specialize "_*" fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    val mappeek : ((list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<b>
          = fn<(e :: E)>(ys: (list :: V -> V)<a>){
            std/core/.lift17187-map-peek<a,b,(e :: E)>(f, ys);
          };
    mappeek(xs);
  };
recursive specialize "_*" fun map-while // inline size: 5
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, action: (a) -> (e :: E) (std/core/types/maybe :: V -> V)<b>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((action(x))) {
          ((std/core/types/Just((y: b) : b) : (std/core/types/maybe :: V -> V)<b> ) as .pat1: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Cons<b>(y, (std/core/map-while<a,b,(e :: E)>(xx, action)));
          ((.skip std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<b> ) as .pat2: ((std/core/types/maybe :: V -> V)<b>))
             -> std/core/Nil<b>;
        });
    });
  };
recursive specialize "_*" fun map.5 // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/Cons<b>((f(x)), (std/core/map.5<a,b,(e :: E)>(xx, f)));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/Nil<b>;
    });
  };
specialize "_*" fun map.6 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(s: std/core/types/string, f: (std/core/types/char) -> (e :: E) std/core/types/char){
    std/core/types/.open<(total :: E),(e :: E),(cs : (list :: V -> V)<std/core/types/char>) -> (total :: E) std/core/types/string,(cs : (list :: V -> V)<std/core/types/char>) -> (e :: E) std/core/types/string>(std/core/string.2)((std/core/map.5<std/core/types/char,std/core/types/char,(e :: E)>((std/core/types/.open<(total :: E),(e :: E),(s : std/core/types/string) -> (total :: E) (list :: V -> V)<std/core/types/char>,(s : std/core/types/string) -> (e :: E) (list :: V -> V)<std/core/types/char>>(std/core/list.6)(s)), f)));
  };
specialize "**" fun map.7 // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> (e :: E) b){
    val w : (std/core/types/vector :: V -> V)<b>
      = std/core/types/.open<(total :: E),(e :: E),(n : std/core/types/ssize_t) -> (total :: E) (std/core/types/vector :: V -> V)<b>,(n : std/core/types/ssize_t) -> (e :: E) (std/core/types/vector :: V -> V)<b>>((std/core/unsafe-vector<b>))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> (e :: E) std/core/types/ssize_t>(std/core/ssize_t)((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<a>) -> std/core/types/int,(v : (std/core/types/vector :: V -> V)<a>) -> (e :: E) std/core/types/int>((std/core/length.2<a>))(v)))));
    val _ : ()
      = std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(i: std/core/types/ssize_t, x: a){
          (std/core/types/.open<(total :: E),(e :: E),(v : (std/core/types/vector :: V -> V)<b>, i : std/core/types/ssize_t, x : b) -> (total :: E) (),(v : (std/core/types/vector :: V -> V)<b>, i : std/core/types/ssize_t, x : b) -> (e :: E) ()>((std/core/unsafe-assign<b>))(w, i, (f(x))));
        }));
    w;
  };
specialize "_*" fun partition // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/partition-acc<a,(e :: E)>(xs, pred, (std/core/Nil<a>), (std/core/Nil<a>));
  };
recursive specialize "_*__" fun partition-acc // inline size: 12
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool, acc1: (list :: V -> V)<a>, acc2: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc1)), (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(acc2)));
      ((.skip std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/partition-acc<a,(e :: E)>(xx, pred, (std/core/Cons<a>(x, acc1)), acc2);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/partition-acc<a,(e :: E)>(xx, pred, acc1, (std/core/Cons<a>(x, acc2)));
        });
    });
  };
specialize "_*" fun remove // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/filter<a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        val b.17147 : std/core/types/bool
              = (pred(x));
        (match (b.17147) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/True;
        });
      }));
  };
specialize "_*" borrow "^_" fun repeat.1 // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/int, action: () -> (e :: E) ()){
    std/core/for<(e :: E)>(1, n, (fn<(e :: E)>(i: std/core/types/int){
        (action());
      }));
  };
specialize "_*" fun show-list // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, show-elem: (a) -> (e :: E) std/core/types/string){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/(++.1))("[", (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(x : std/core/types/string, y : std/core/types/string) -> std/core/types/string,(x : std/core/types/string, y : std/core/types/string) -> (e :: E) std/core/types/string>(std/core/(++.1))((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> std/core/types/string,(xs : (list :: V -> V)<std/core/types/string>, sep : std/core/types/string) -> (e :: E) std/core/types/string>((fn(xs0: (list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
          val join-acc : ((ys : (list :: V -> V)<std/core/types/string>, acc : std/core/types/string) -> std/core/types/string)
                = (fn(ys: (list :: V -> V)<std/core/types/string>, acc: std/core/types/string){
                  (std/core/.lift17192-show-list(sep, ys, acc));
                });
          (match (xs0) {
            ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
               -> "";
            ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
               -> join-acc(xx, x);
          });
        }))((std/core/map.5<a,std/core/types/string,(e :: E)>(xs, show-elem)), ",")), "]")));
  };
specialize "_*" fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    val span-acc : ((list :: V -> V)<a>, (list :: V -> V)<a>) -> (e :: E) ((list :: V -> V)<a>, (list :: V -> V)<a>)
          = fn<(e :: E)>(ys: (list :: V -> V)<a>, acc: (list :: V -> V)<a>){
            std/core/.lift17202-span<a,(e :: E)>(predicate, ys, acc);
          };
    span-acc(xs, (std/core/Nil<a>));
  };
recursive specialize "_*" fun take-while // inline size: 5
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match ((predicate(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/Cons<a>(x, (std/core/take-while<a,(e :: E)>(xx, predicate)));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/Nil<a>;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
recursive specialize "**" fun while // inline size: 4
  = forall<(e :: E)> fn<<(std/core/types/div :: X)|(e :: E)>>(predicate: () -> <(std/core/types/div :: X)|(e :: E)> std/core/types/bool, action: () -> <(std/core/types/div :: X)|(e :: E)> ()){
    (match ((predicate())) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> val _ : ()
                  = action();
        std/core/while<(e :: E)>(predicate, action);
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/();
    });
  };
recursive specialize "__*" fun zipwith // inline size: 5
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>, f: (a, b) -> (e :: E) c){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> (match (ys) {
          ((std/core/Cons((y: b) : b, (yy: (list :: V -> V)<b>) : (list :: V -> V)<b>) : (list :: V -> V)<b> ) as .pat0: ((list :: V -> V)<b>))
             -> std/core/Cons<c>((f(x, y)), (std/core/zipwith<a,b,c,(e :: E)>(xx, yy, f)));
          ((.skip std/core/Nil() : (list :: V -> V)<b> ) as .pat1: ((list :: V -> V)<b>))
             -> std/core/Nil<c>;
        });
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<c>;
    });
  };
specialize "__*" fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (list :: V -> V)<a>, ys0: (list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    val zipwith-iter : (std/core/types/int, (list :: V -> V)<a>, (list :: V -> V)<b>) -> (e :: E) (list :: V -> V)<c>
          = fn<(e :: E)>(i: std/core/types/int, xs: (list :: V -> V)<a>, ys: (list :: V -> V)<b>){
            std/core/.lift17207-zipwith-indexed<a,b,c,(e :: E)>(f, i, xs, ys);
          };
    zipwith-iter(0, xs0, ys0);
  };
inline borrow "^" fun is-exnError // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnError() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnAssert // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnAssert() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnTodo // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnTodo() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnRange // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnRange() : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat0: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnPattern // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnPattern((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/string) : std/core/types/string) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat2: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnSystem // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnSystem((.pat0: std/core/types/int) : std/core/types/int) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat1: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun is-exnInternal // inline size: 1
  = fn(exception-info: exception-info){
    match (exception-info) {
      ((std/core/ExnInternal((.pat0: std/core/types/string) : std/core/types/string) : exception-info ) as .pat: exception-info)
         -> std/core/types/True;
      (.pat1: exception-info)
         -> std/core/types/False;
    };
  };
inline borrow "^" fun message // inline size: 0
  = fn(exception: exception){
    match (exception) {
      ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat0: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
inline borrow "^" fun info // inline size: 0
  = fn(exception: exception){
    match (exception) {
      ((.skip std/core/Exception((.pat0: std/core/types/string) : std/core/types/string, (.x: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
fun .copy // inline size: 3
  = fn(.this: exception, message0: (std/core/types/optional :: V -> V)<std/core/types/string>, info0: (std/core/types/optional :: V -> V)<exception-info>){
    std/core/Exception((match (message0) {
        ((std/core/types/Optional((.message.1688: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .message.1688;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> (match (.this) {
            ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat00: exception-info) : exception-info) : exception ) as .pat1: exception)
               -> .x;
          });
      }), (match (info0) {
        ((std/core/types/Optional((.info.1694: exception-info) : exception-info) : (std/core/types/optional :: V -> V)<exception-info> ) as .pat10: ((std/core/types/optional :: V -> V)<exception-info>))
           -> .info.1694;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<exception-info> ) as .pat2: ((std/core/types/optional :: V -> V)<exception-info>))
           -> (match (.this) {
            ((.skip std/core/Exception((.pat01: std/core/types/string) : std/core/types/string, (.x0: exception-info) : exception-info) : exception ) as .pat3: exception)
               -> .x0;
          });
      }));
  };
inline borrow "^" fun dref // inline size: 0
  = forall<(e :: E),a> fn(delayed: (delayed :: (E, V) -> V)<(e :: E),a>){
    (match (delayed) {
      ((.skip std/core/Delay((.x: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (delayed :: (E, V) -> V)<(e :: E),a> ) as .pat: ((delayed :: (E, V) -> V)<(e :: E),a>))
         -> .x;
    });
  };
fun .copy.1 // inline size: 2
  = forall<(e :: E),a> fn(.this: (delayed :: (E, V) -> V)<(e :: E),a>, dref0: (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>){
    std/core/Delay<(e :: E),a>((match (dref0) {
      ((std/core/types/Optional((.dref.1727: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>> ) as .pat: ((std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>))
         -> .dref.1727;
      ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>> ) as .pat0: ((std/core/types/optional :: V -> V)<(std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>>))
         -> (match (.this) {
          ((.skip std/core/Delay((.x: (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (std/core/types/ref :: (H, V) -> V)<(std/core/types/global :: H),(std/core/types/either :: (V, V) -> V)<() -> (e :: E) a,a>>) : (delayed :: (E, V) -> V)<(e :: E),a> ) as .pat1: ((delayed :: (E, V) -> V)<(e :: E),a>))
             -> .x;
        });
    }));
  };
inline borrow "^" fun is-error // inline size: 1
  = forall<a> fn(error: (error :: V -> V)<a>){
    (match (error) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/True;
      (.pat3: ((error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-ok // inline size: 1
  = forall<a> fn(error: (error :: V -> V)<a>){
    (match (error) {
      ((std/core/Ok((.pat0: a) : a) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/True;
      (.pat1: ((error :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-nil // inline size: 1
  = forall<a> fn(list0: (list :: V -> V)<a>){
    (match (list0) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun is-cons // inline size: 1
  = forall<a> fn(list0: (list :: V -> V)<a>){
    (match (list0) {
      ((std/core/Cons((.pat0: a) : a, (.pat1: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
inline borrow "^" fun str // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.x: std/core/types/string) : std/core/types/string, (.pat0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
inline borrow "^" fun start // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
inline borrow "^" fun len // inline size: 0
  = fn(sslice: sslice){
    match (sslice) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    };
  };
fun .copy.2 // inline size: 4
  = fn(.this: sslice, str0: (std/core/types/optional :: V -> V)<std/core/types/string>, start0: (std/core/types/optional :: V -> V)<std/core/types/ssize_t>, len0: (std/core/types/optional :: V -> V)<std/core/types/ssize_t>){
    std/core/Sslice((match (str0) {
        ((std/core/types/Optional((.str.1826: std/core/types/string) : std/core/types/string) : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> .str.1826;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/string>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.x: std/core/types/string) : std/core/types/string, (.pat00: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat10: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat1: sslice)
               -> .x;
          });
      }), (match (start0) {
        ((std/core/types/Optional((.start.1832: std/core/types/ssize_t) : std/core/types/ssize_t) : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat11: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> .start.1832;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat2: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.pat01: std/core/types/string) : std/core/types/string, (.x0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat12: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat3: sslice)
               -> .x0;
          });
      }), (match (len0) {
        ((std/core/types/Optional((.len.1838: std/core/types/ssize_t) : std/core/types/ssize_t) : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat30: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> .len.1838;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/ssize_t> ) as .pat4: ((std/core/types/optional :: V -> V)<std/core/types/ssize_t>))
           -> (match (.this) {
            ((.skip std/core/Sslice((.pat02: std/core/types/string) : std/core/types/string, (.pat13: std/core/types/ssize_t) : std/core/types/ssize_t, (.x1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat5: sslice)
               -> .x1;
          });
      }));
  };
inline borrow "^" fun head // inline size: 0
  = forall<a> fn(stream: (stream :: V -> V)<a>){
    (match (stream) {
      ((.skip std/core/Next((.x: a) : a, (.pat0: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat: ((stream :: V -> V)<a>))
         -> .x;
    });
  };
inline borrow "^" fun tail // inline size: 0
  = forall<a> fn(stream: (stream :: V -> V)<a>){
    (match (stream) {
      ((.skip std/core/Next((.pat0: a) : a, (.x: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat: ((stream :: V -> V)<a>))
         -> .x;
    });
  };
fun .copy.3 // inline size: 3
  = forall<a> fn(.this: (stream :: V -> V)<a>, head0: (std/core/types/optional :: V -> V)<a>, tail0: (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>){
    std/core/Next<a>((match (head0) {
        ((std/core/types/Optional((.head.1884: a) : a) : (std/core/types/optional :: V -> V)<a> ) as .pat: ((std/core/types/optional :: V -> V)<a>))
           -> .head.1884;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<a> ) as .pat0: ((std/core/types/optional :: V -> V)<a>))
           -> (match (.this) {
            ((.skip std/core/Next((.x: a) : a, (.pat00: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat1: ((stream :: V -> V)<a>))
               -> .x;
          });
      }), (match (tail0) {
        ((std/core/types/Optional((.tail.1891: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>> ) as .pat10: ((std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>))
           -> .tail.1891;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<(stream :: V -> V)<a>> ) as .pat2: ((std/core/types/optional :: V -> V)<(stream :: V -> V)<a>>))
           -> (match (.this) {
            ((.skip std/core/Next((.pat01: a) : a, (.x0: (stream :: V -> V)<a>) : (stream :: V -> V)<a>) : (stream :: V -> V)<a> ) as .pat3: ((stream :: V -> V)<a>))
               -> .x0;
          });
      }));
  };
inline borrow "^" fun .select-throw-exn // inline size: 0
  = forall<a,(e :: E),b> fn(hnd: (.hnd-exn :: (E, V) -> V)<(e :: E),b>){
    (match (hnd) {
      ((.skip std/core/.Hnd-exn((ctl-throw-exn: (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,c,(.hnd-exn :: (E, V) -> V),(e :: E),b>)) : (forall<c> (std/core/hnd/clause1 :: (V, V, (E, V) -> V, E, V) -> V)<exception,c,(.hnd-exn :: (E, V) -> V),(e :: E),b>)) : (.hnd-exn :: (E, V) -> V)<(e :: E),b> ) as .pat: ((.hnd-exn :: (E, V) -> V)<(e :: E),b>))
         -> ctl-throw-exn<a>;
    });
  };
fun .new-sslice // inline size: 1
  = fn(str0: std/core/types/string, start0: std/core/types/ssize_t, len0: std/core/types/ssize_t){
    std/core/Sslice(str0, start0, len0);
  };
fun int.8 // inline size: 1
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> 1;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> 0;
    };
  };
fun int.9 // inline size: 2
  = fn(x: std/core/types/order){
    match (x) {
      ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
         -> -1;
      ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
         -> 0;
      ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
         -> 1;
    };
  };
fun string.4 // inline size: 1
  = fn(ms: (std/core/types/maybe :: V -> V)<std/core/types/string>){
    match (ms) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/types/Just((s: std/core/types/string) : std/core/types/string) : (std/core/types/maybe :: V -> V)<std/core/types/string> ) as .pat0: ((std/core/types/maybe :: V -> V)<std/core/types/string>))
         -> s;
    };
  };
fun apply // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(f: (a) -> (e :: E) b, x: a){
    f(x);
  };
fun concat // inline size: 1
  = forall<a> fn(xss: (list :: V -> V)<(list :: V -> V)<a>>){
    std/core/.lift17183-concat<a>((std/core/Nil<a>), xss);
  };
inline fun const // inline size: 0
  = forall<a,b> fn(x: a, y: b){
    x;
  };
inline fun const.1 // inline size: 0
  = forall<a,b> fn<(total :: E)>(default0: a){
    fn(._wildcard_110_6: b){
      default0;
    };
  };
fun default // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>, nothing: a){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> nothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> x;
    });
  };
fun default.1 // inline size: 1
  = forall<a> fn(t: (error :: V -> V)<a>, def: a){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> def;
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat3: ((error :: V -> V)<a>))
         -> x;
    });
  };
fun either // inline size: 3
  = forall<a> fn(t: (error :: V -> V)<a>){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat0: std/core/types/string) : std/core/types/string, (.pat1: exception-info) : exception-info) : exception ) as exn0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/Left<exception,a>(exn0);
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat2: ((error :: V -> V)<a>))
         -> std/core/types/Right<exception,a>(x);
    });
  };
fun flatmap // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (a) -> (e :: E) (list :: V -> V)<b>){
    std/core/.lift17184-flatmap<a,b,(e :: E)>(f, (std/core/Nil<b>), xs);
  };
fun reverse-append // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, tl: (list :: V -> V)<a>){
    std/core/.lift17185-reverse-append<a>(tl, xs);
  };
inline fun ignore // inline size: 0
  = forall<a> fn(x: a){
    std/core/types/();
  };
fun intersperse // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, sep: a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/Cons<a>(x, (std/core/.lift17186-intersperse<a>(sep, xx)));
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat2: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
fun is-even // inline size: 2
  = fn(i: std/core/types/int){
    val b.16946 : std/core/types/bool
          = std/core/is-odd(i);
    match (b.16946) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun map-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    std/core/.lift17187-map-peek<a,b,(e :: E)>(f, xs);
  };
fun mbint // inline size: 1
  = fn(m: (std/core/types/maybe :: V -> V)<std/core/types/int>){
    match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/maybe :: V -> V)<std/core/types/int>))
         -> 0;
      ((.skip std/core/types/Just((i: std/core/types/int) : std/core/types/int) : (std/core/types/maybe :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/maybe :: V -> V)<std/core/types/int>))
         -> i;
    };
  };
fun negate // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(~)(i);
  };
fun o // inline size: 2
  = forall<a,b,c,(e :: E)> fn(f: (a) -> (e :: E) b, g: (c) -> (e :: E) a){
    fn<(e :: E)>(x: c){
      f((g(x)));
    };
  };
fun on-exit // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(hndler: () -> (e :: E) (), action: () -> (e :: E) a){
    std/core/hnd/finally<a,(e :: E)>(hndler, action);
  };
fun single // inline size: 1
  = forall<a> fn(x: a){
    std/core/Cons<a>(x, (std/core/Nil<a>));
  };
fun unsafe-no-exn // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> a,(action : () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a) -> (e :: E) a>((std/core/types/unsafe-total<a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>))(action);
  };
fun (!=.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
         -> y;
    };
  };
fun (+.4) // inline size: 1
  = fn(x: std/core/types/int, y: std/core/types/int){
    std/core/int-add(x, y);
  };
fun (+.3) // inline size: 4
  = fn<(total :: E)>(c: std/core/types/char, d: std/core/types/char){
    val x.16954 : std/core/types/int
      = std/core/int(c);
    val y.16955 : std/core/types/int
      = std/core/int(d);
    std/core/char((std/core/int-add(x.16954, y.16955)));
  };
fun (++) // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, ys: (list :: V -> V)<a>){
    std/core/append<a>(xs, ys);
  };
fun (-.4) // inline size: 1
  = fn(x: std/core/types/int, y: std/core/types/int){
    std/core/int-sub(x, y);
  };
fun (-.3) // inline size: 4
  = fn<(total :: E)>(c: std/core/types/char, d: std/core/types/char){
    val x.16956 : std/core/types/int
      = std/core/int(c);
    val y.16957 : std/core/types/int
      = std/core/int(d);
    std/core/char((std/core/int-sub(x.16956, y.16957)));
  };
fun (==.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> y;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
    };
  };
fun (<.6) // inline size: 1
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun order // inline size: 4
  = fn(i: std/core/types/int){
    match ((std/core/(<.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.1)(i, 0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun (<.7) // inline size: 4
  = fn(x: std/core/types/string, y: std/core/types/string){
    val x0.16965 : std/core/types/order
          = std/core/compare.3(x, y);
    std/core/(==.1)((match (x0.16965) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), -1);
  };
fun (>.4) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/True;
        });
      (.pat01: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun (>.5) // inline size: 4
  = fn(x: std/core/types/string, y: std/core/types/string){
    val x0.16972 : std/core/types/order
          = std/core/compare.3(x, y);
    std/core/(==.1)((match (x0.16972) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), 1);
  };
fun compare.1 // inline size: 4
  = fn(x: std/core/types/char, y: std/core/types/char){
    match ((std/core/(<)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>)(x, y))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun (>=.5) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> std/core/types/True;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat02: std/core/types/bool)
             -> std/core/types/True;
        });
    };
  };
fun (>=.6) // inline size: 4
  = fn(x: std/core/types/string, y: std/core/types/string){
    val x0.16988 : std/core/types/order
          = std/core/compare.3(x, y);
    std/core/(>.1)((match (x0.16988) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), -1);
  };
fun joinsep // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17188-joinsep(sep, xx, x);
    };
  };
fun join.2 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17189-join.2(xx, x);
    };
  };
fun join.3 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/string>, sep: std/core/types/string){
    std/core/joinsep(xs, sep);
  };
fun (<=.6) // inline size: 2
  = fn(x: std/core/types/bool, y: std/core/types/bool){
    match (x) {
      ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
         -> (match (y) {
          ((std/core/types/True() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/True;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat00: std/core/types/bool)
             -> std/core/types/False;
        });
      (.pat01: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun (<=.7) // inline size: 4
  = fn(x: std/core/types/string, y: std/core/types/string){
    val x0.17000 : std/core/types/order
          = std/core/compare.3(x, y);
    std/core/(<.1)((match (x0.17000) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), 1);
  };
fun inc // inline size: 1
  = fn(i: std/core/types/int){
    std/core/int-add(i, 1);
  };
fun decr // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/(-)(i, (std/core/int32(1)));
  };
fun incr // inline size: 2
  = fn(i: std/core/types/int32){
    std/core/(+)(i, (std/core/int32(1)));
  };
fun forz // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) ()){
    std/core/.lift17190-forz<(e :: E)>(action, end, start0);
  };
fun length.1 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/.lift17191-length.1<a>(xs, 0);
  };
borrow "^" fun length.2 // inline size: 2
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<a>){
    std/core/int.2((std/core/lengthz<a>(v)));
  };
fun list.4 // inline size: 4
  = fn<(total :: E)>(lo: std/core/types/char, hi: std/core/types/char){
    std/core/map.5<std/core/types/int,std/core/types/char,(total :: E)>((std/core/list((std/core/int(lo)), (std/core/int(hi)))), std/core/char);
  };
fun list.5 // inline size: 2
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/Nil<a>;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/Cons<a>(x, (std/core/Nil<a>));
    });
  };
fun list.7 // inline size: 1
  = forall<a> fn(v: (std/core/types/vector :: V -> V)<a>){
    std/core/vlist<a>(v, (std/core/types/None<(list :: V -> V)<a>>));
  };
fun map // inline size: 3
  = forall<a,b,(e :: E)> fn<(e :: E)>(m: (std/core/types/maybe :: V -> V)<a>, f: (a) -> (e :: E) b){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/Just<b>((f(x)));
    });
  };
fun map.1 // inline size: 4
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(e: (std/core/types/either :: (V, V) -> V)<a,b>, f: (b) -> (e :: E) c){
    (match (e) {
      ((std/core/types/Right((x: b) : b) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Right<a,c>((f(x)));
      ((.skip std/core/types/Left((x0: a) : a) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat0: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Left<a,c>(x0);
    });
  };
fun sign.1 // inline size: 4
  = fn(d: std/core/types/float64){
    match ((std/core/(<.4)(d, 0.0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Lt;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> (match ((std/core/(>.2)(d, 0.0))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Gt;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat2: std/core/types/bool)
             -> std/core/types/Eq;
        });
    };
  };
fun is-pos.2 // inline size: 4
  = fn(i: std/core/types/int){
    val x.17015 : std/core/types/order
          = std/core/sign(i);
    std/core/(==.1)((match (x.17015) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), 1);
  };
fun is-pos.3 // inline size: 1
  = fn(d: std/core/types/float64){
    std/core/(>.2)(d, 0.0);
  };
fun is-empty // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/True;
      (.pat0: ((list :: V -> V)<a>))
         -> std/core/types/False;
    });
  };
fun is-empty.1 // inline size: 2
  = fn(slice0: sslice){
    val b.17019 : std/core/types/bool
          = std/core/is-pos.1((match (slice0) {
            ((.skip std/core/Sslice((.pat00: std/core/types/string) : std/core/types/string, (.pat10: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat1: sslice)
               -> .x;
          }));
    match (b.17019) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/False;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/True;
    };
  };
fun is-empty.2 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(==.3)(s, "");
  };
fun (||) // inline size: 1
  = forall<a> fn(m1: (std/core/types/maybe :: V -> V)<a>, m2: (std/core/types/maybe :: V -> V)<a>){
    (match (m1) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> m2;
      (.pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> m1;
    });
  };
fun (||.1) // inline size: 2
  = fn(x: std/core/types/string, y: std/core/types/string){
    match ((std/core/(==.3)(x, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> y;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> x;
    };
  };
fun show-exp // inline size: 3
  = fn(d: std/core/types/float64, precision: (std/core/types/optional :: V -> V)<std/core/types/int>){
    std/core/show-expx(d, (std/core/int32((match (precision) {
        ((std/core/types/Optional((.precision.8116: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> .precision.8116;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
           -> -17;
      }))));
  };
inline fun show.10 // inline size: 0
  = fn(exn0: exception){
    match (exn0) {
      ((.skip std/core/Exception((.x: std/core/types/string) : std/core/types/string, (.pat0: exception-info) : exception-info) : exception ) as .pat: exception)
         -> .x;
    };
  };
fun show.2 // inline size: 3
  = fn(c: std/core/types/char){
    std/core/(++.1)("\x27", (std/core/(++.1)((std/core/show-char(c)), "\x27")));
  };
fun show.4 // inline size: 1
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    };
  };
inline fun show.5 // inline size: 0
  = fn(u: ()){
    "()";
  };
fun show.6 // inline size: 2
  = fn(s: sslice){
    std/core/show.3((std/core/string.3(s)));
  };
fun show.7 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    std/core/show-list<std/core/types/string,(std/core/types/(<>) :: E)>(xs, std/core/show.3);
  };
fun show.8 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/int>){
    std/core/show-list<std/core/types/int,(std/core/types/(<>) :: E)>(xs, std/core/show);
  };
fun show.9 // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/bool>){
    std/core/show-list<std/core/types/bool,(std/core/types/(<>) :: E)>(xs, std/core/show.4);
  };
fun println // inline size: 1
  = fn<<(console :: X)>>(s: std/core/types/string){
    std/core/printsln(s);
  };
fun println.1 // inline size: 2
  = fn<<(console :: X)>>(i: std/core/types/int){
    std/core/printsln((std/core/show(i)));
  };
fun println.2 // inline size: 2
  = fn<<(console :: X)>>(d: std/core/types/float64){
    std/core/printsln((std/core/show.1(d, (std/core/types/None<std/core/types/int>))));
  };
fun println.3 // inline size: 2
  = fn<<(console :: X)>>(b: std/core/types/bool){
    std/core/printsln((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    }));
  };
fun println.4 // inline size: 2
  = fn<<(console :: X)>>(c: std/core/types/char){
    std/core/printsln((std/core/string(c)));
  };
fun println.5 // inline size: 1
  = fn<<(console :: X)>>(u: ()){
    std/core/printsln("()");
  };
inline fun throw-exn // inline size: 5
  = forall<a> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>>(exn0: exception){
    std/core/hnd/.perform1<exception,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(.hnd-exn :: (E, V) -> V)>((std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(i : std/core/hnd/ev-index) -> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>,(i : std/core/hnd/ev-index) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> (std/core/hnd/ev :: ((E, V) -> V) -> V)<(.hnd-exn :: (E, V) -> V)>>((std/core/hnd/.evv-at<(.hnd-exn :: (E, V) -> V)>))((std/core/types/.open<(std/core/types/(<>) :: E),<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,(i : std/core/types/int) -> std/core/types/ssize_t,(i : std/core/types/int) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> std/core/types/ssize_t>(std/core/ssize_t)(0)))), (forall<(e :: E),b> std/core/.select-throw-exn<a,(e :: E),b>), exn0);
  };
fun (^.1) // inline size: 1
  = fn(i: std/core/types/int, exp: std/core/types/int){
    std/core/pow(i, exp);
  };
fun assert // inline size: 2
  = fn(message0: std/core/types/string, condition: std/core/types/bool){
    match (condition) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/();
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/unsafe-assert-fail(message0);
    };
  };
fun before // inline size: 2
  = fn(slice0: sslice){
    match (slice0) {
      ((.skip std/core/Sslice((s: std/core/types/string) : std/core/types/string, (start0: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat0: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> std/core/Sslice(s, (std/core/ssize_t(0)), start0);
    };
  };
fun bool // inline size: 1
  = fn(i: std/core/types/int){
    std/core/(!=.1)(i, 0);
  };
fun bool.1 // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/False;
      (.pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> std/core/types/True;
    });
  };
fun bool.2 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(!=.3)(s, "");
  };
fun catch // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(action: () -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a, hndl: (exception) -> (e :: E) a){
    std/core/try<a,(e :: E)>(action, hndl);
  };
fun for-whilez // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/ssize_t, end: std/core/types/ssize_t, action: (std/core/types/ssize_t) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/core/.lift17194-for-whilez<a,(e :: E)>(action, end, start0);
  };
fun slice // inline size: 3
  = fn(s: std/core/types/string){
    std/core/Sslice(s, (std/core/ssize_t(0)), (std/core/length(s)));
  };
fun foreach.1 // inline size: 2
  = forall<(e :: E)> fn<(e :: E)>(slice0: sslice, action: (c : std/core/types/char) -> (e :: E) ()){
    val _0 : (std/core/types/maybe :: V -> V)<_a>
          = std/core/foreach-while.1<_a,(e :: E)>(slice0, (fn<(e :: E)>(c: std/core/types/char){
              val _ : ()
                    = (action(c));
              (std/core/types/Nothing<_a>);
            }));
    std/core/types/();
  };
fun foreach.3 // inline size: 2
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (a) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(._wildcard_1874_26: std/core/types/ssize_t, x: a){
        (f(x));
      }));
  };
fun dec // inline size: 1
  = fn(i: std/core/types/int){
    std/core/int-sub(i, 1);
  };
fun exp10 // inline size: 1
  = fn(exp: std/core/types/int){
    std/core/mul-exp10(1, exp);
  };
fun is-neg.2 // inline size: 4
  = fn(i: std/core/types/int){
    val x.17067 : std/core/types/order
          = std/core/sign(i);
    std/core/(==.1)((match (x.17067) {
        ((std/core/types/Lt() : std/core/types/order ) as .pat: std/core/types/order)
           -> -1;
        ((std/core/types/Eq() : std/core/types/order ) as .pat0: std/core/types/order)
           -> 0;
        ((.skip std/core/types/Gt() : std/core/types/order ) as .pat1: std/core/types/order)
           -> 1;
      }), -1);
  };
fun is-neg.3 // inline size: 1
  = fn(d: std/core/types/float64){
    std/core/(<.4)(d, 0.0);
  };
fun exn // inline size: 1
  = forall<a> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>>(err: (error :: V -> V)<a>){
    std/core/untry<a>(err);
  };
fun exp2 // inline size: 1
  = fn(exp: std/core/types/int){
    std/core/pow(2, exp);
  };
fun is-zero.2 // inline size: 1
  = fn(d: std/core/types/float64){
    std/core/(==.2)(d, 0.0);
  };
fun find // inline size: 4
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<a,a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        (match ((pred(x))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/Just<a>(x);
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/Nothing<a>;
        });
      }));
  };
fun find-maybe // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<a>, pred: (a) -> (std/core/types/maybe :: V -> V)<b>){
    std/core/foreach-while<a,b,(std/core/types/(<>) :: E)>(xs, pred);
  };
fun fold-int.1 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(upto: std/core/types/int, init0: a, f: (std/core/types/int, a) -> (e :: E) a){
    std/core/fold-int<a,(e :: E)>(0, (std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/int) -> std/core/types/int,(i : std/core/types/int) -> (e :: E) std/core/types/int>((fn(i: std/core/types/int){
        (std/core/int-sub(i, 1));
      }))(upto)), init0, f);
  };
fun foldl1 // inline size: 4
  = forall<a,(e :: E)> fn<<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xs: (list :: V -> V)<a>, f: (a, a) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/foldl<a,a,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>>(xx, x, f);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/.open<<(std/core/types/handled :: HX -> X)<(exn :: HX)>>,<(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)>,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>> a,(message : std/core/types/string, info : (std/core/types/optional :: V -> V)<exception-info>) -> <(std/core/types/handled :: HX -> X)<(exn :: HX)>|(e :: E)> a>((std/core/throw<a>))("unexpected Nil in std/core/foldl1", (std/core/types/None<exception-info>));
    });
  };
fun reverse // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/.lift17195-reverse<a>((std/core/Nil<a>), xs);
  };
fun foldr // inline size: 4
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, z: b, f: (a, b) -> (e :: E) b){
    std/core/foldl<a,b,(e :: E)>((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(xs : (list :: V -> V)<a>) -> (list :: V -> V)<a>,(xs : (list :: V -> V)<a>) -> (e :: E) (list :: V -> V)<a>>((std/core/reverse<a>))(xs)), z, (fn<(e :: E)>(x: b, y: a){
        (f(y, x));
      }));
  };
borrow "^__" fun for // inline size: 1
  = forall<(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) ()){
    std/core/.lift17196-for<(e :: E)>(action, end, start0);
  };
fun for-while // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(start0: std/core/types/int, end: std/core/types/int, action: (std/core/types/int) -> (e :: E) (std/core/types/maybe :: V -> V)<a>){
    std/core/.lift17197-for-while<a,(e :: E)>(action, end, start0);
  };
fun foreach-indexed.1 // inline size: 4
  = forall<a,(e :: E)> fn<(e :: E)>(v: (std/core/types/vector :: V -> V)<a>, f: (std/core/types/int, a) -> (e :: E) ()){
    std/core/foreach-indexedz<a,(e :: E)>(v, (fn<(e :: E)>(i: std/core/types/ssize_t, x: a){
        (f((std/core/types/.open<(std/core/types/(<>) :: E),(e :: E),(i : std/core/types/ssize_t) -> std/core/types/int,(i : std/core/types/ssize_t) -> (e :: E) std/core/types/int>(std/core/int.2)(i)), x));
      }));
  };
fun print // inline size: 1
  = fn<<(console :: X)>>(s: std/core/types/string){
    std/core/prints(s);
  };
fun print.1 // inline size: 2
  = fn<<(console :: X)>>(i: std/core/types/int){
    std/core/prints((std/core/show(i)));
  };
fun print.2 // inline size: 2
  = fn<<(console :: X)>>(d: std/core/types/float64){
    std/core/prints((std/core/show.1(d, (std/core/types/None<std/core/types/int>))));
  };
fun print.3 // inline size: 2
  = fn<<(console :: X)>>(b: std/core/types/bool){
    std/core/prints((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> "True";
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> "False";
    }));
  };
fun print.4 // inline size: 2
  = fn<<(console :: X)>>(c: std/core/types/char){
    std/core/prints((std/core/string(c)));
  };
fun print.5 // inline size: 1
  = fn<<(console :: X)>>(u: ()){
    std/core/prints("()");
  };
fun gprint // inline size: 2
  = forall<a> fn<<(console :: X)>>(x: a){
    val s.17100 : std/core/types/string
          = std/core/gshow<a>(x);
    std/core/prints(s.17100);
  };
fun gprintln // inline size: 2
  = forall<a> fn<<(console :: X)>>(x: a){
    val s.17101 : std/core/types/string
          = std/core/gshow<a>(x);
    std/core/printsln(s.17101);
  };
fun head.1 // inline size: 2
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (.pat0: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
    });
  };
fun head.2 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, default0: a){
    (match (xs) {
      ((std/core/Cons((x: a) : a, (.pat0: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> x;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> default0;
    });
  };
fun head-char // inline size: 4
  = fn(s: std/core/types/string){
    std/core/foreach-while.1<std/core/types/char,(std/core/types/(<>) :: E)>((std/core/Sslice(s, (std/core/ssize_t(0)), (std/core/length(s)))), (std/core/types/Just<std/core/types/char>));
  };
inline fun i32 // inline size: 1
  = fn(i: std/core/types/int){
    std/core/int32(i);
  };
inline fun i64 // inline size: 1
  = fn(i: std/core/types/int){
    std/core/int64(i);
  };
fun index-of // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/index-of-acc<a>(xs, pred, 0);
  };
fun is-lower // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, 'a'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, 'z');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-upper // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, 'A'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, 'Z');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-digit // inline size: 3
  = fn(c: std/core/types/char){
    match ((std/core/(>=)(c, '0'))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/(<=)(c, '9');
      (.pat0: std/core/types/bool)
         -> std/core/types/False;
    };
  };
fun is-ascii // inline size: 1
  = fn(c: std/core/types/char){
    std/core/(<=)(c, '\x7F');
  };
fun is-control // inline size: 1
  = fn(c: std/core/types/char){
    std/core/(<)(c, ' ');
  };
fun is-notempty // inline size: 1
  = fn(slice0: sslice){
    std/core/is-pos.1((match (slice0) {
      ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t, (.x: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
         -> .x;
    }));
  };
fun is-notempty.1 // inline size: 1
  = fn(s: std/core/types/string){
    std/core/(!=.3)(s, "");
  };
fun is-valid // inline size: 2
  = fn(slice0: sslice){
    std/core/(>=.2)((match (slice0) {
        ((.skip std/core/Sslice((.pat0: std/core/types/string) : std/core/types/string, (.x: std/core/types/ssize_t) : std/core/types/ssize_t, (.pat1: std/core/types/ssize_t) : std/core/types/ssize_t) : sslice ) as .pat: sslice)
           -> .x;
      }), (std/core/ssize_t(0)));
  };
fun join-end // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/string>, end: std/core/types/string){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat: ((list :: V -> V)<std/core/types/string>))
         -> "";
      (.pat0: ((list :: V -> V)<std/core/types/string>))
         -> std/core/(++.1)((std/core/joinsep(xs, end)), end);
    };
  };
fun split // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, n: std/core/types/int){
    std/core/types/(,)<(list :: V -> V)<a>,(list :: V -> V)<a>>((std/core/take<a>(xs, n)), (std/core/drop<a>(xs, n)));
  };
fun split.1 // inline size: 2
  = fn(s: std/core/types/string, sep: std/core/types/string){
    val v.17122 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv(s, sep);
    std/core/vlist<std/core/types/string>(v.17122, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
borrow "__^" fun split.2 // inline size: 3
  = fn(s: std/core/types/string, sep: std/core/types/string, n: std/core/types/int){
    val v.17123 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv.1(s, sep, (std/core/ssize_t(n)));
    std/core/vlist<std/core/types/string>(v.17123, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
fun lines // inline size: 2
  = fn(s: std/core/types/string){
    val v.17126 : (std/core/types/vector :: V -> V)<std/core/types/string>
          = std/core/splitv(s, "\x0A");
    std/core/vlist<std/core/types/string>(v.17126, (std/core/types/None<(list :: V -> V)<std/core/types/string>>));
  };
fun lookup // inline size: 4
  = forall<a,b> fn(xs: (list :: V -> V)<(a, b)>, pred: (a) -> std/core/types/bool){
    std/core/foreach-while<(a, b),b,(std/core/types/(<>) :: E)>(xs, (fn(kv: (a, b)){
        (match ((pred((match (kv) {
          ((.skip std/core/types/(,)((.x: a) : a, (.pat0: b) : b) : (a, b) ) as .pat: (a, b))
             -> .x;
        })))) {
          ((std/core/types/True() : std/core/types/bool ) as .pat1: std/core/types/bool)
             -> std/core/types/Just<b>((match (kv) {
              ((.skip std/core/types/(,)((.pat00: a) : a, (.x0: b) : b) : (a, b) ) as .pat2: (a, b))
                 -> .x0;
            }));
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat01: std/core/types/bool)
             -> std/core/types/Nothing<b>;
        });
      }));
  };
fun map-indexed // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a) -> (e :: E) b){
    std/core/.lift17198-map-indexed<a,b,(e :: E)>(f, xs, 0);
  };
fun map-indexed-peek // inline size: 1
  = forall<a,b,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, f: (idx : std/core/types/int, value : a, rest : (list :: V -> V)<a>) -> (e :: E) b){
    std/core/.lift17199-map-indexed-peek<a,b,(e :: E)>(f, xs, 0);
  };
fun max // inline size: 2
  = fn(i: std/core/types/int, j: std/core/types/int){
    match ((std/core/(>=.1)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun max.1 // inline size: 2
  = fn(x: std/core/types/float64, y: std/core/types/float64){
    match ((std/core/(>=.3)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun maximum // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/int>, default0: (std/core/types/optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/int> ) as .pat1: ((list :: V -> V)<std/core/types/int>))
         -> (match (default0) {
          ((std/core/types/Optional((.default.14393: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .default.14393;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((.skip std/core/Cons((x: std/core/types/int) : std/core/types/int, (xx: (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int> ) as .pat2: ((list :: V -> V)<std/core/types/int>))
         -> std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xx, x, std/core/max);
    };
  };
fun maximum.1 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/float64>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/float64> ) as .pat: ((list :: V -> V)<std/core/types/float64>))
         -> 0.0;
      ((.skip std/core/Cons((x: std/core/types/float64) : std/core/types/float64, (xx: (list :: V -> V)<std/core/types/float64>) : (list :: V -> V)<std/core/types/float64>) : (list :: V -> V)<std/core/types/float64> ) as .pat0: ((list :: V -> V)<std/core/types/float64>))
         -> std/core/foldl<std/core/types/float64,std/core/types/float64,(std/core/types/(<>) :: E)>(xx, x, std/core/max.1);
    };
  };
fun maybe // inline size: 2
  = forall<a,b,(e :: E)> fn<(e :: E)>(m: (std/core/types/maybe :: V -> V)<a>, onNothing: b, onJust: (a) -> (e :: E) b){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> onNothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> onJust(x);
    });
  };
fun maybe.1 // inline size: 1
  = forall<a> fn(m: (std/core/types/maybe :: V -> V)<a>, nothing: a){
    (match (m) {
      ((std/core/types/Nothing() : (std/core/types/maybe :: V -> V)<a> ) as .pat: ((std/core/types/maybe :: V -> V)<a>))
         -> nothing;
      ((.skip std/core/types/Just((x: a) : a) : (std/core/types/maybe :: V -> V)<a> ) as .pat0: ((std/core/types/maybe :: V -> V)<a>))
         -> x;
    });
  };
fun maybe.2 // inline size: 2
  = forall<a,b> fn(e: (std/core/types/either :: (V, V) -> V)<a,b>){
    (match (e) {
      ((std/core/types/Left((.pat0: a) : a) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Nothing<b>;
      ((.skip std/core/types/Right((x: b) : b) : (std/core/types/either :: (V, V) -> V)<a,b> ) as .pat1: ((std/core/types/either :: (V, V) -> V)<a,b>))
         -> std/core/types/Just<b>(x);
    });
  };
fun maybe.3 // inline size: 2
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Nil() : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/Cons((x: a) : a, (.pat1: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat0: ((list :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
    });
  };
fun maybe.4 // inline size: 2
  = fn(b: std/core/types/bool){
    match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Just<()>(std/core/types/());
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Nothing<()>;
    };
  };
fun maybe.5 // inline size: 3
  = fn(i: std/core/types/int){
    match ((std/core/(==.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/int>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/int>(i);
    };
  };
fun maybe.6 // inline size: 3
  = fn(s: std/core/types/string){
    match ((std/core/(==.3)(s, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/string>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/string>(s);
    };
  };
fun maybe.7 // inline size: 2
  = forall<a> fn(t: (error :: V -> V)<a>){
    (match (t) {
      ((std/core/Error(((.skip std/core/Exception((.pat1: std/core/types/string) : std/core/types/string, (.pat2: exception-info) : exception-info) : exception ) as .pat0: exception) : exception) : (error :: V -> V)<a> ) as .pat: ((error :: V -> V)<a>))
         -> std/core/types/Nothing<a>;
      ((.skip std/core/Ok((x: a) : a) : (error :: V -> V)<a> ) as .pat3: ((error :: V -> V)<a>))
         -> std/core/types/Just<a>(x);
    });
  };
fun min // inline size: 2
  = fn(i: std/core/types/int, j: std/core/types/int){
    match ((std/core/(<=.1)(i, j))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> i;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> j;
    };
  };
fun min.1 // inline size: 2
  = fn(x: std/core/types/float64, y: std/core/types/float64){
    match ((std/core/(<=.4)(x, y))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> x;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> y;
    };
  };
fun minimum // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/int>, default0: (std/core/types/optional :: V -> V)<std/core/types/int>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/int> ) as .pat1: ((list :: V -> V)<std/core/types/int>))
         -> (match (default0) {
          ((std/core/types/Optional((.default.14872: std/core/types/int) : std/core/types/int) : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> .default.14872;
          ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/int> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/int>))
             -> 0;
        });
      ((.skip std/core/Cons((x: std/core/types/int) : std/core/types/int, (xx: (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int>) : (list :: V -> V)<std/core/types/int> ) as .pat2: ((list :: V -> V)<std/core/types/int>))
         -> std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xx, x, std/core/min);
    };
  };
fun minimum.1 // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/float64>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/float64> ) as .pat: ((list :: V -> V)<std/core/types/float64>))
         -> 0.0;
      ((.skip std/core/Cons((x: std/core/types/float64) : std/core/types/float64, (xx: (list :: V -> V)<std/core/types/float64>) : (list :: V -> V)<std/core/types/float64>) : (list :: V -> V)<std/core/types/float64> ) as .pat0: ((list :: V -> V)<std/core/types/float64>))
         -> std/core/foldl<std/core/types/float64,std/core/types/float64,(std/core/types/(<>) :: E)>(xx, x, std/core/min.1);
    };
  };
fun null.1 // inline size: 4
  = fn(i: std/core/types/int){
    std/core/null<std/core/types/int>((match ((std/core/(==.1)(i, 0))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/int>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/int>(i);
    }));
  };
fun null.2 // inline size: 4
  = fn(s: std/core/types/string){
    std/core/null<std/core/types/string>((match ((std/core/(==.3)(s, ""))) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Nothing<std/core/types/string>;
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Just<std/core/types/string>(s);
    }));
  };
fun null.3 // inline size: 3
  = fn(b: std/core/types/bool){
    std/core/null<()>((match (b) {
      ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
         -> std/core/types/Just<()>(std/core/types/());
      ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
         -> std/core/types/Nothing<()>;
    }));
  };
fun trim // inline size: 2
  = fn(s: std/core/types/string){
    std/core/trim-right((std/core/trim-left(s)));
  };
fun parse-int // inline size: 4
  = fn(s: std/core/types/string, hex: (std/core/types/optional :: V -> V)<std/core/types/bool>){
    std/core/xparse-int((std/core/trim-right((std/core/trim-left(s)))), (match (hex) {
        ((std/core/types/Optional((.hex.15544: std/core/types/bool) : std/core/types/bool) : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> .hex.15544;
        ((.skip std/core/types/None() : (std/core/types/optional :: V -> V)<std/core/types/bool> ) as .pat0: ((std/core/types/optional :: V -> V)<std/core/types/bool>))
           -> std/core/types/False;
      }));
  };
fun partition // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, pred: (a) -> (e :: E) std/core/types/bool){
    std/core/partition-acc<a,(e :: E)>(xs, pred, (std/core/Nil<a>), (std/core/Nil<a>));
  };
fun remove // inline size: 3
  = forall<a> fn(xs: (list :: V -> V)<a>, pred: (a) -> std/core/types/bool){
    std/core/filter<a,(std/core/types/(<>) :: E)>(xs, (fn(x: a){
        val b.17147 : std/core/types/bool
              = (pred(x));
        (match (b.17147) {
          ((std/core/types/True() : std/core/types/bool ) as .pat: std/core/types/bool)
             -> std/core/types/False;
          ((.skip std/core/types/False() : std/core/types/bool ) as .pat0: std/core/types/bool)
             -> std/core/types/True;
        });
      }));
  };
borrow "_^" fun repeat // inline size: 2
  = fn(s: std/core/types/string, n: std/core/types/int){
    std/core/repeatz(s, (std/core/ssize_t(n)));
  };
borrow "^_" fun repeat.1 // inline size: 2
  = forall<(e :: E)> fn<(e :: E)>(n: std/core/types/int, action: () -> (e :: E) ()){
    std/core/for<(e :: E)>(1, n, (fn<(e :: E)>(i: std/core/types/int){
        (action());
      }));
  };
fun reverse-join // inline size: 3
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    val xs0.17151 : (list :: V -> V)<std/core/types/string>
          = std/core/.lift17200-reverse-join<std/core/types/string>((std/core/Nil<std/core/types/string>), xs);
    match (xs0.17151) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat10: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x0: std/core/types/string) : std/core/types/string, (xx0: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17201-reverse-join(xx0, x0);
    };
  };
fun span // inline size: 1
  = forall<a,(e :: E)> fn<(e :: E)>(xs: (list :: V -> V)<a>, predicate: (a) -> (e :: E) std/core/types/bool){
    std/core/.lift17202-span<a,(e :: E)>(predicate, xs, (std/core/Nil<a>));
  };
fun sum // inline size: 1
  = fn(xs: (list :: V -> V)<std/core/types/int>){
    std/core/foldl<std/core/types/int,std/core/types/int,(std/core/types/(<>) :: E)>(xs, 0, std/core/(+.4));
  };
fun tail.1 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    (match (xs) {
      ((std/core/Cons((.pat0: a) : a, (xx: (list :: V -> V)<a>) : (list :: V -> V)<a>) : (list :: V -> V)<a> ) as .pat: ((list :: V -> V)<a>))
         -> xx;
      ((.skip std/core/Nil() : (list :: V -> V)<a> ) as .pat1: ((list :: V -> V)<a>))
         -> std/core/Nil<a>;
    });
  };
fun unlines // inline size: 2
  = fn(xs: (list :: V -> V)<std/core/types/string>){
    match (xs) {
      ((std/core/Nil() : (list :: V -> V)<std/core/types/string> ) as .pat1: ((list :: V -> V)<std/core/types/string>))
         -> "";
      ((.skip std/core/Cons((x: std/core/types/string) : std/core/types/string, (xx: (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string>) : (list :: V -> V)<std/core/types/string> ) as .pat2: ((list :: V -> V)<std/core/types/string>))
         -> std/core/.lift17203-unlines(xx, x);
    };
  };
fun unzip // inline size: 1
  = forall<a,b> fn(xs: (list :: V -> V)<(a, b)>){
    std/core/.lift17204-unzip<a,b>(xs, (std/core/Nil<a>), (std/core/Nil<b>));
  };
borrow "^_" fun vector.2 // inline size: 2
  = forall<a> fn(n: std/core/types/int, default0: a){
    std/core/vector-initz<a>((std/core/ssize_t(n)), (fn(._wildcard_1854_30: std/core/types/ssize_t){
        default0;
      }));
  };
fun vector.3 // inline size: 1
  = forall<a> fn(xs: (list :: V -> V)<a>){
    std/core/unvlist<a>(xs);
  };
borrow "^_" fun vector-init // inline size: 4
  = forall<a> fn(n: std/core/types/int, f: (std/core/types/int) -> a){
    std/core/vector-initz<a>((std/core/ssize_t(n)), (fn(i: std/core/types/ssize_t){
        (f((std/core/int.2(i))));
      }));
  };
fun zipwith-indexed // inline size: 1
  = forall<a,b,c,(e :: E)> fn<(e :: E)>(xs0: (list :: V -> V)<a>, ys0: (list :: V -> V)<b>, f: (std/core/types/int, a, b) -> (e :: E) c){
    std/core/.lift17207-zipwith-indexed<a,b,c,(e :: E)>(f, 0, xs0, ys0);
  };